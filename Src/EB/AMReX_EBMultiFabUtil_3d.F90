module amrex_eb_util_module
  use amrex_fort_module, only : amrex_real
  implicit none
  
  private
  public :: amrex_eb_avgdown_sv, amrex_eb_avgdown, amrex_eb_avgdown_faces, &
       amrex_eb_avgdown_boundaries, amrex_compute_eb_divergence

contains

  subroutine amrex_eb_avgdown_sv (lo, hi, fine, flo, fhi, crse, clo, chi, &
       fv, fvlo, fvhi, vfrc, vflo, vfhi, lrat, ncomp) bind(c,name='amrex_eb_avgdown_sv')
    integer, intent(in) :: lo(3), hi(3), flo(3), fhi(3), clo(3), chi(3), &
         fvlo(3), fvhi(3), vflo(3), vfhi(3), lrat(3), ncomp
    real(amrex_real), intent(in   ) :: fine( flo(1): fhi(1), flo(2): fhi(2), flo(3): fhi(3),ncomp)
    real(amrex_real), intent(inout) :: crse( clo(1): chi(1), clo(2): chi(2), clo(3): chi(3),ncomp)
    real(amrex_real), intent(in   ) :: fv  (fvlo(1):fvhi(1),fvlo(2):fvhi(2),fvlo(3):fvhi(3))
    real(amrex_real), intent(in   ) :: vfrc(vflo(1):vfhi(1),vflo(2):vfhi(2),vflo(3):vfhi(3))
    
    integer :: i, j, k, ii, jj, kk, n, iref, jref, kref
    real(amrex_real) :: cv
    
    do n = 1, ncomp
       do k        = lo(3), hi(3)
          kk       = k * lrat(3)
          do j     = lo(2), hi(2)
             jj    = j * lrat(2)
             do i  = lo(1), hi(1)
                ii = i * lrat(1)
                crse(i,j,k,n) = 0.d0
                cv            = 0.d0
                do       kref = 0, lrat(3)-1
                   do    jref = 0, lrat(2)-1
                      do iref = 0, lrat(1)-1
                         cv = cv + (fv(ii+iref,jj+jref,kk+kref)*vfrc(ii+iref,jj+jref,kk+kref))
                         crse(i,j,k,n) = crse(i,j,k,n) + &
                              fine(ii+iref,jj+jref,kk+kref,n)*(fv(ii+iref,jj+jref,kk+kref)*vfrc(ii+iref,jj+jref,kk+kref))
                      end do
                   end do
                end do
                if (cv .gt. 1.d-30) then
                   crse(i,j,k,n) = crse(i,j,k,n) / cv
                else
                   crse(i,j,k,n) = fine(ii,jj,kk,n)  ! covered cell
                end if
             end do
          end do
       end do
    end do
  end subroutine amrex_eb_avgdown_sv


  subroutine amrex_eb_avgdown (lo, hi, fine, flo, fhi, crse, clo, chi, &
       vfrc, vflo, vfhi, lrat, ncomp) bind(c,name='amrex_eb_avgdown')
    integer, intent(in) :: lo(3), hi(3), flo(3), fhi(3), clo(3), chi(3), &
         vflo(3), vfhi(3), lrat(3), ncomp
    real(amrex_real), intent(in   ) :: fine( flo(1): fhi(1), flo(2): fhi(2), flo(3): fhi(3),ncomp)
    real(amrex_real), intent(inout) :: crse( clo(1): chi(1), clo(2): chi(2), clo(3): chi(3),ncomp)
    real(amrex_real), intent(in   ) :: vfrc(vflo(1):vfhi(1),vflo(2):vfhi(2),vflo(3):vfhi(3))
    
    integer :: i, j, k, ii, jj, kk, n, iref, jref, kref
    real(amrex_real) :: cv
    
    do n = 1, ncomp
       do k        = lo(3), hi(3)
          kk       = k * lrat(3)
          do j     = lo(2), hi(2)
             jj    = j * lrat(2)
             do i  = lo(1), hi(1)
                ii = i * lrat(1)
                crse(i,j,k,n) = 0.d0
                cv            = 0.d0
                do       kref = 0, lrat(3)-1
                   do    jref = 0, lrat(2)-1
                      do iref = 0, lrat(1)-1
                         cv = cv + vfrc(ii+iref,jj+jref,kk+kref)
                         crse(i,j,k,n) = crse(i,j,k,n) + &
                              fine(ii+iref,jj+jref,kk+kref,n)*vfrc(ii+iref,jj+jref,kk+kref)
                      end do
                   end do
                end do
                if (cv .gt. 1.d-30) then
                   crse(i,j,k,n) = crse(i,j,k,n) / cv
                else
                   crse(i,j,k,n) = fine(ii,jj,kk,n)  ! covered cell
                end if
             end do
          end do
       end do
    end do
  end subroutine amrex_eb_avgdown
  
  subroutine amrex_eb_avgdown_faces (lo, hi, fine, flo, fhi, crse, clo, chi, &
       ap, aplo, aphi, lrat, idir, ncomp) bind(c,name='amrex_eb_avgdown_faces')
    integer, dimension(3), intent(in) :: lo, hi, flo, fhi, clo,chi, aplo, aphi, lrat
    integer,               intent(in) :: idir, ncomp
    real(amrex_real),   intent(in   ) :: fine( flo(1): fhi(1), flo(2): fhi(2), flo(3): fhi(3),ncomp) 
    real(amrex_real),   intent(inout) :: crse( clo(1): chi(1), clo(2): chi(2), clo(3): chi(3),ncomp)
    real(amrex_real),   intent(in   ) ::   ap(aplo(1):aphi(1),aplo(2):aphi(2),aplo(3):aphi(3))

    integer  :: i, j, k, ii, jj, kk, n, iref, jref, kref
    real(amrex_real) :: fa 
 
    if(idir.eq.0) then 
      do n              = 1, ncomp
         do k           = lo(3), hi(3)
            kk          = k*lrat(3)
            do j        = lo(2), hi(2)
               jj       = j*lrat(2)
               do i     = lo(1), hi(1)
                  ii    = i*lrat(1)
                  crse(i,j,k,n) = 0.d0
                  fa            = 0.d0
                  do    kref    = 0, lrat(3)-1
                    do  jref    = 0, lrat(2)-1
                        fa            = fa + ap(ii,jj+jref,kk+kref)
                        crse(i,j,k,n) = crse(i,j,k,n) + ap(ii,jj+jref,kk+kref)*fine(ii,jj+jref,kk+kref,n)
                    enddo
                  enddo
                  if(fa.gt.1.d-30) then 
                    crse(i,j,k,n) = crse(i,j,k,n)/fa
                  else
                    crse(i,j,k,n) = fine(ii,jj,kk,n) !covered face
                  endif
               enddo
            enddo
         enddo
      enddo 
    elseif(idir.eq.1) then 
      do n             = 1, ncomp   
         do k          = lo(3), hi(3)
            kk         = k*lrat(3)
            do j       = lo(2), hi(2)
               jj      = j*lrat(2)
               do i    = lo(1), hi(1)
                  ii   = i*lrat(1)
                  crse(i,j,k,n) = 0.d0
                  fa            = 0.d0
                  do    kref    = 0, lrat(3)-1
                    do  iref    = 0, lrat(1)-1
                        fa            = fa + ap(ii+iref, jj, kk+kref)
                        crse(i,j,k,n) = crse(i,j,k,n) + ap(ii+iref,jj,kk+kref)*fine(ii+iref,jj,kk+kref,n)
                    enddo
                  enddo
                  if(fa.gt.1.d-30) then
                    crse(i,j,k,n) = crse(i,j,k,n)/fa
                  else
                    crse(i,j,k,n) = fine(ii,jj,kk,n) !covered face
                  endif
               enddo
            enddo
         enddo
      enddo
    else
      do n            = 1, ncomp
         do k         = lo(3), hi(3)
            kk        = k*lrat(3)
            do j      = lo(2), hi(2)
               jj     = j*lrat(2)
               do i   = lo(1), hi(1)
                  ii  = i*lrat(1)
                  crse(i,j,k,n) = 0.d0
                  fa            = 0.d0
                  do    jref    = 0, lrat(2)-1
                    do  iref    = 0, lrat(1)-1
                        fa            = fa + ap(ii+iref,jj+jref,kk)
                        crse(i,j,k,n) = crse(i,j,k,n) + ap(ii+iref,jj+jref,kk)*fine(ii+iref,jj+jref,kk,n)
                    enddo
                  enddo
                  if(fa.gt.1.d-30) then
                    crse(i,j,k,n) = crse(i,j,k,n)/fa
                  else
                    crse(i,j,k,n) = fine(ii,jj,kk,n) !covered face
                  endif
               enddo
            enddo
         enddo
      enddo
    endif
  end subroutine amrex_eb_avgdown_faces

  
  subroutine amrex_eb_avgdown_boundaries (lo, hi, fine, flo, fhi, crse, clo, chi, &
       ba, blo, bhi, lrat, ncomp) bind(c,name='amrex_eb_avgdown_boundaries')
    use amrex_constants_module, only : zero
    integer, dimension(3), intent(in) :: lo, hi, flo, fhi, clo, chi, blo, bhi, lrat
    integer,               intent(in) :: ncomp
    real(amrex_real),   intent(in   ) :: fine(flo(1):fhi(1),flo(2):fhi(2),flo(3):fhi(3),ncomp) 
    real(amrex_real),   intent(inout) :: crse(clo(1):chi(1),clo(2):chi(2),clo(3):chi(3),ncomp)
    real(amrex_real),   intent(in   ) ::  ba (blo(1):bhi(1),blo(2):bhi(2),blo(3):bhi(3))

    integer  :: i, j, k, ii, jj, kk, n, iref, jref, kref
    real(amrex_real) :: fa 
 
    do n              = 1, ncomp
       do k           = lo(3), hi(3)
          kk          = k*lrat(3)
          do j        = lo(2), hi(2)
             jj       = j*lrat(2)
             do i     = lo(1), hi(1)
                ii    = i*lrat(1)
                crse(i,j,k,n) = 0.d0
                fa            = 0.d0
                do    kref    = 0, lrat(3)-1
                   do  jref   = 0, lrat(2)-1
                      do iref = 0, lrat(1)-1
                         fa            = fa            + ba(ii+iref,jj+jref,kk+kref)
                         crse(i,j,k,n) = crse(i,j,k,n) + ba(ii+iref,jj+jref,kk+kref) &
                              &                       *fine(ii+iref,jj+jref,kk+kref,n)
                      enddo
                   enddo
                end do
                if(fa.gt.1.d-30) then 
                   crse(i,j,k,n) = crse(i,j,k,n)/fa
                else
                   crse(i,j,k,n) = zero
                endif
             enddo
          enddo
       enddo
    end do
  end subroutine amrex_eb_avgdown_boundaries

  subroutine amrex_compute_eb_divergence (lo, hi, divu, dlo, dhi, &
       u, ulo, uhi, v, vlo, vhi, w, wlo, whi, &
       ccm, cmlo, cmhi, flag, flo, fhi, vfrc, klo, khi, &
       apx, axlo, axhi, apy, aylo, ayhi, apz, azlo, azhi, &
       fcx, cxlo, cxhi, fcy, cylo, cyhi, fcz, czlo, czhi, &
       dxinv) bind(c,name='amrex_compute_eb_divergence')
    use amrex_constants_module, only : zero, one
    use amrex_ebcellflag_module, only : is_regular_cell, is_covered_cell, is_single_valued_cell
    implicit none
    integer, dimension(3), intent(in) :: lo, hi, dlo, dhi, ulo, uhi, vlo, vhi, wlo, whi, &
         cmlo, cmhi, flo, fhi, klo, khi, axlo, axhi, aylo, ayhi, azlo, azhi, &
         cxlo, cxhi, cylo, cyhi, czlo, czhi
    real(amrex_real), intent(inout) :: divu(dlo(1):dhi(1),dlo(2):dhi(2),dlo(3):dhi(3))
    real(amrex_real), intent(in   ) ::    u(ulo(1):uhi(1),ulo(2):uhi(2),ulo(3):uhi(3))
    real(amrex_real), intent(in   ) ::    v(vlo(1):vhi(1),vlo(2):vhi(2),vlo(3):vhi(3))
    real(amrex_real), intent(in   ) ::    w(wlo(1):whi(1),wlo(2):whi(2),wlo(3):whi(3))
    integer         , intent(in   ) ::  ccm(cmlo(1):cmhi(1),cmlo(2):cmhi(2),cmlo(3):cmhi(3)) 
    integer         , intent(in   ) :: flag( flo(1): fhi(1), flo(2): fhi(2), flo(3): fhi(3)) 
    real(amrex_real), intent(in   ) :: vfrc( klo(1): khi(1), klo(2): khi(2), klo(3): khi(3)) 
    real(amrex_real), intent(in   ) ::  apx(axlo(1):axhi(1),axlo(2):axhi(2),axlo(3):axhi(3)) 
    real(amrex_real), intent(in   ) ::  apy(aylo(1):ayhi(1),aylo(2):ayhi(2),aylo(3):ayhi(3))
    real(amrex_real), intent(in   ) ::  apz(azlo(1):azhi(1),azlo(2):azhi(2),azlo(3):azhi(3))
    real(amrex_real), intent(in   ) ::  fcx(cxlo(1):cxhi(1),cxlo(2):cxhi(2),cxlo(3):cxhi(3),2)
    real(amrex_real), intent(in   ) ::  fcy(cylo(1):cyhi(1),cylo(2):cyhi(2),cylo(3):cyhi(3),2) 
    real(amrex_real), intent(in   ) ::  fcz(czlo(1):czhi(1),czlo(2):czhi(2),czlo(3):czhi(3),2) 
    real(amrex_real), intent(in) :: dxinv(3)

    integer :: i,j,k,ii,jj,kk
    real(amrex_real) :: fxm, fxp, fym, fyp, fzm, fzp, fracx, fracy, fracz

    do       k = lo(3), hi(3)
       do    j = lo(2), hi(2)
          do i = lo(1), hi(1)
             if (is_covered_cell(flag(i,j,k))) then
                divu(i,j,k) = zero
             else if (is_regular_cell(flag(i,j,k))) then
                divu(i,j,k) = dxinv(1) * (u(i+1,j,k)-u(i,j,k)) &
                     +        dxinv(2) * (v(i,j+1,k)-v(i,j,k)) &
                     +        dxinv(3) * (w(i,j,k+1)-w(i,j,k))
             else
                fxm = u(i,j,k)
                if (apx(i,j,k).ne.zero.and.apx(i,j,k).ne.one) then 
                    jj = j + int(sign(one, fcx(i,j,k,1)))
                    kk = k + int(sign(one, fcx(i,j,k,2)))
                    fracy = abs(fcx(i,j,k,1))*real(ior(ccm(i-1,jj,k),ccm(i,jj,k)),amrex_real)
                    fracz = abs(fcx(i,j,k,2))*real(ior(ccm(i-1,j,kk),ccm(i,j,kk)),amrex_real)
                    fxm = (one-fracy)*(one-fracz)*fxm + &
                         & fracy*(one-fracz)*u(i,jj,k ) + &
                         & fracz*(one-fracy)*u(i,j ,kk) + &
                         & fracy*     fracz *u(i,jj,kk)
                endif 

                fxp = u(i+1,j,k)
                if (apx(i+1,j,k).ne.zero.and.apx(i+1,j,k).ne.one) then 
                    jj = j + int(sign(one,fcx(i+1,j,k,1)))
                    kk = k + int(sign(one,fcx(i+1,j,k,2)))
                    fracy = abs(fcx(i+1,j,k,1))*real(ior(ccm(i,jj,k),ccm(i+1,jj,k)),amrex_real)
                    fracz = abs(fcx(i+1,j,k,2))*real(ior(ccm(i,j,kk),ccm(i+1,j,kk)),amrex_real)
                    fxp = (one-fracy)*(one-fracz)*fxp + &
                         & fracy*(one-fracz)*u(i+1,jj,k ) + & 
                         & fracz*(one-fracy)*u(i+1,j ,kk) + & 
                         & fracy*     fracz *u(i+1,jj,kk)
                endif 

                fym = v(i,j,k)
                if (apy(i,j,k).ne.zero.and.apy(i,j,k).ne.one) then 
                    ii = i + int(sign(one,fcy(i,j,k,1)))
                    kk = k + int(sign(one,fcy(i,j,k,2)))
                    fracx = abs(fcy(i,j,k,1))*real(ior(ccm(ii,j-1,k),ccm(ii,j,k)),amrex_real)
                    fracz = abs(fcy(i,j,k,2))*real(ior(ccm(i,j-1,kk),ccm(i,j,kk)),amrex_real)
                    fym = (one-fracx)*(one-fracz)*fym + &
                         & fracx*(one-fracz)*v(ii,j,k ) + & 
                         & fracz*(one-fracx)*v(i ,j,kk) + &
                         & fracx*     fracz *v(ii,j,kk)
                endif 

                fyp = v(i,j+1,k)
                if (apy(i,j+1,k).ne.zero.and.apy(i,j+1,k).ne.one) then 
                    ii = i + int(sign(one,fcy(i,j+1,k,1)))
                    kk = k + int(sign(one,fcy(i,j+1,k,2)))
                    fracx = abs(fcy(i,j+1,k,1))*real(ior(ccm(ii,j,k),ccm(ii,j+1,k)),amrex_real)
                    fracz = abs(fcy(i,j+1,k,2))*real(ior(ccm(i,j,kk),ccm(i,j+1,kk)),amrex_real)
                    fyp = (one-fracx)*(one-fracz)*fyp + &
                         & fracx*(one-fracz)*v(ii,j+1,k ) + &
                         & fracz*(one-fracx)*v(i ,j+1,kk) + & 
                         & fracx*     fracz *v(ii,j+1,kk)
                endif 

                fzm = w(i,j,k)
                if (apz(i,j,k).ne.zero.and.apz(i,j,k).ne.one) then 
                    ii = i + int(sign(one,fcz(i,j,k,1)))
                    jj = j + int(sign(one,fcz(i,j,k,2)))
                    fracx = abs(fcz(i,j,k,1))*real(ior(ccm(ii,j,k-1),ccm(ii,j,k)),amrex_real)
                    fracy = abs(fcz(i,j,k,2))*real(ior(ccm(i,jj,k-1),ccm(i,jj,k)),amrex_real)
                    fzm = (one-fracx)*(one-fracy)*fzm + &
                         & fracx*(one-fracy)*w(ii,j ,k) + & 
                         & fracy*(one-fracx)*w(i ,jj,k) + &
                         & fracx*     fracy *w(ii,jj,k)
                endif 

                fzp = w(i,j,k+1)
                if (apz(i,j,k+1).ne.zero.and.apz(i,j,k+1).ne.one) then 
                    ii = i + int(sign(one,fcz(i,j,k+1,1)))
                    jj = j + int(sign(one,fcz(i,j,k+1,2)))
                    fracx = abs(fcz(i,j,k+1,1))*real(ior(ccm(ii,j,k),ccm(ii,j,k+1)),amrex_real)
                    fracy = abs(fcz(i,j,k+1,2))*real(ior(ccm(i,jj,k),ccm(i,jj,k+1)),amrex_real)
                    fzp = (one-fracx)*(one-fracy)*fzp + & 
                         & fracx*(one-fracy)*w(ii,j ,k+1) + &
                         & fracy*(one-fracx)*w(i ,jj,k+1) + &
                         & fracx*     fracy *w(ii,jj,k+1)
                endif

                divu(i,j,k) = (one/vfrc(i,j,k)) * &
                     ( dxinv(1) * (apx(i+1,j,k)*fxp-apx(i,j,k)*fxm) &
                     + dxinv(2) * (apy(i,j+1,k)*fyp-apy(i,j,k)*fym) &
                     + dxinv(3) * (apz(i,j,k+1)*fzp-apz(i,j,k)*fzm) )
             end if
          end do
       end do
    end do
  end subroutine amrex_compute_eb_divergence

end module amrex_eb_util_module
