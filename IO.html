

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Plotfile &mdash; amrex 18.03-dev documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="amrex 18.03-dev documentation" href="index.html"/>
        <link rel="up" title="I/O (Plotfile, Checkpoint)" href="Chapter6a.html"/>
        <link rel="next" title="Linear Solvers" href="Chapter7.html"/>
        <link rel="prev" title="I/O (Plotfile, Checkpoint)" href="Chapter6a.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                18.03-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter2.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter3.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter4.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter5.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter6.html">Amr Source Code</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Chapter6a.html">I/O (Plotfile, Checkpoint)</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Plotfile</a></li>
<li class="toctree-l2"><a class="reference internal" href="#checkpoint-file">Checkpoint File</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Chapter7.html">Linear Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter8.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter9.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter10.html">Embedded Boundaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter11.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter12.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter13.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter14.html">CVODE</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="Chapter6a.html">I/O (Plotfile, Checkpoint)</a> &raquo;</li>
        
      <li>Plotfile</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/IO.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="plotfile">
<span id="sec-io"></span><h1>Plotfile<a class="headerlink" href="#plotfile" title="Permalink to this headline">¶</a></h1>
<p>AMReX&nbsp;has its own native plotfile format. Many visualization tools are
available for AMReX&nbsp;plotfiles (see the chapter on&nbsp;<a class="reference internal" href="Chapter11.html#chap-visualization"><span class="std std-ref">Visualization</span></a>).
AMReX&nbsp;provides the following two functions for writing a generic AMReX&nbsp;plotfile.
Many AMReX&nbsp;application codes may have their own plotfile routines that store
additional information such as compiler options, git hashes of the
source codes and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> runtime parameters.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">WriteSingleLevelPlotfile</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">plotfilename</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">MultiFab</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">varnames</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span><span class="n">geom</span><span class="p">,</span>
                               <span class="n">Real</span> <span class="n">time</span><span class="p">,</span>
                               <span class="kt">int</span> <span class="n">level_step</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">WriteMultiLevelPlotfile</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">plotfilename</span><span class="p">,</span>
                              <span class="kt">int</span> <span class="n">nlevels</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MultiFab</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">varnames</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">geom</span><span class="p">,</span>
                              <span class="n">Real</span> <span class="n">time</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">level_steps</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">IntVect</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ref_ratio</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">WriteSingleLevelPlotfile</span></span></code> is for single level runs and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">WriteMultiLevelPlotfile</span></span></code> is for multiple levels. The name of the
plotfile is specified by the plotfilename argument. This is the
top level directory name for the plotfile. In AMReX&nbsp;convention, the
plotfile name consist of letters followed by numbers (e.g.,
plt00258). <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Concatenate</span></span></code> is a useful helper function for
making such strings.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">istep</span> <span class="o">=</span> <span class="mi">258</span><span class="p">;</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">);</span> <span class="c1">// plt00258</span>

<span class="c1">// By default there are 5 digits, but we can change it to say 4.</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname2</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// plt0258</span>

<span class="n">istep</span> <span class="o">=</span><span class="mi">1234567</span><span class="p">;</span>  <span class="c1">// Having more than 5 digits is OK.</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname3</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">);</span> <span class="c1">// plt12344567</span>
</pre></div>
</div>
<p>The argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">mf</span></span></code> above (<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> for single level and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword"><span class="pre">const</span></span> <span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">*&gt;</span></span></code> for multi-level) is the data to be written
to the disk. Note that many visualization tools expect this to be
cell-centered data. So for nodal data, we need to convert them to
cell-centered data through some kind of averaging. Also note that if
you have data at each AMR level in several MultiFabs, you need
to build a new MultiFab at each level to hold all the data on
that level. This involves local data copy in memory and is not
expected to significantly increase the total wall time for writing
plotfiles. For the multi-level version, the function expects
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword"><span class="pre">const</span></span> <span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">*&gt;</span></span></code>, whereas the multi-level data are often
stored as <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">unique_ptr</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">&gt;&gt;</span></span></code>. AMReX&nbsp;has a
helper function for this and one can use it as follows,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">WriteMultiLevelPlotfile</span><span class="p">(......,</span> <span class="n">amrex</span><span class="o">::</span><span class="n">GetVecOfConstPtrs</span><span class="p">(</span><span class="n">mf</span><span class="p">),</span> <span class="p">......);</span>
</pre></div>
</div>
<p>The argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">varnames</span></span></code> has the names for each component of the
MultiFab data. The size of the Vector should be equal to the
number of components. The argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">geom</span></span></code> is for passing
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> objects that contain the physical domain
information. The argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">time</span></span></code> is for the time associated with the
data. The argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">level_step</span></span></code> is for the current time step
associated with the data. For multi-level plotfiles, the argument
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">nlevels</span></span></code> is the total number of levels, and we also need to provide
the refinement ratio via an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span></code> of size nlevels-1.</p>
<p>We note that AMReX&nbsp;does not overwrite old plotfiles if the new
plotfile has the same name. The old plotfiles will be renamed to
new directories named like plt00350.old.46576787980.</p>
</div>
<div class="section" id="checkpoint-file">
<h1>Checkpoint File<a class="headerlink" href="#checkpoint-file" title="Permalink to this headline">¶</a></h1>
<p>Checkpoint files are used for restarting simulations from where the
checkpoints are written. Each application code has its own set of
data needed for restart. AMReX provides I/O functions for basic
data structures like <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>. These
functions can be used to build codes for reading and writing
checkpoint files. Since each application code has its own
requirement, there is no standard AMReX checkpoint format.
However we have provided an example restart capability in the tutorial
<code class="docutils literal notranslate"><span class="pre">/amrex/Tutorials/Amr/Advection_AmrCore/Exec/SingleVortex</span></code>.
Refer to the functions <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ReadCheckpointFile</span></span><span class="punctuation"><span class="pre">()</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">WriteCheckpointFile</span></span><span class="punctuation"><span class="pre">()</span></span></code> in this tutorial.</p>
<p>A checkpoint file is actually a directory with name, e.g.,
<code class="docutils literal notranslate"><span class="pre">chk00010</span></code> containing a <code class="docutils literal notranslate"><span class="pre">Header</span></code> (text) file, along with
subdirectories <code class="docutils literal notranslate"><span class="pre">Level_0</span></code>, <code class="docutils literal notranslate"><span class="pre">Level_1</span></code>, etc. containing the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> data at each level of refinement.
The <code class="docutils literal notranslate"><span class="pre">Header</span></code> file contains problem-specific data (such as the
finest level, simulation time, time step, etc.), along with a printout
of the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> at each level of refinement.</p>
<p>When starting a simulation from a checkpoint file, a typical sequence in the code
could be:</p>
<ul>
<li><p class="first">Read in the <code class="docutils literal notranslate"><span class="pre">Header</span></code> file data (except for the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> data).</p>
</li>
<li><p class="first">For each level of refinement, do the following in order:</p>
<p>– Read in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code></p>
<p>– Build a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code></p>
<p>– Define any <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FluxRegister</span></span></code>, etc. objects that are built upon the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> and the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code></p>
<p>– Read in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> data</p>
</li>
</ul>
<p>We do this one level at a time because when you create a distribution map,
it checks how much allocated <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> data already exists before assigning
grids to processors.</p>
<p>Typically a checkpoint file is a directory containing some text files
and sub-directories (e.g., <code class="docutils literal notranslate"><span class="pre">Level_0</span></code> and <code class="docutils literal notranslate"><span class="pre">Level_1</span></code>)
containing various data. It is a good idea that we fist make these
directories ready for subsequently writing to the disk. For example,
to build directories <code class="docutils literal notranslate"><span class="pre">chk00010</span></code>, <code class="docutils literal notranslate"><span class="pre">chk00010/Level_0</span></code>, and
<code class="docutils literal notranslate"><span class="pre">chk00010/Level_1</span></code>, you could write:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">checkpointname</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s">&quot;chk&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>

<span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Writing checkpoint &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">checkpointname</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">nlevels</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">callBarrier</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="c1">// ---- prebuild a hierarchy of directories</span>
<span class="c1">// ---- dirName is built first.  if dirName exists, it is renamed.  then build</span>
<span class="c1">// ---- dirName/subDirPrefix_0 .. dirName/subDirPrefix_nlevels-1</span>
<span class="c1">// ---- if callBarrier is true, call ParallelDescriptor::Barrier()</span>
<span class="c1">// ---- after all directories are built</span>
<span class="c1">// ---- ParallelDescriptor::IOProcessor() creates the directories</span>
<span class="n">amrex</span><span class="o">::</span><span class="n">PreBuildDirectorHierarchy</span><span class="p">(</span><span class="n">checkpointname</span><span class="p">,</span> <span class="s">&quot;Level_&quot;</span><span class="p">,</span> <span class="n">nlevels</span><span class="p">,</span> <span class="n">callBarrier</span><span class="p">);</span>
</pre></div>
</div>
<p>A checkpoint file of AMReX application codes often has a clear text
Header file that only the I/O process writes to it using
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ofstream</span></span></code>. The Header file contains problem-dependent
information such as
the time, the physical domain size, grids, etc. that are necessary for
restarting the simulation. To guarantee that precision is not lost
for storing floating point number like time in clear text file, the
file stream’s precision needs to be set properly. And a stream buffer
can also be used. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// write Header file</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">IOProcessor</span><span class="p">())</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">HeaderFileName</span><span class="p">(</span><span class="n">checkpointname</span> <span class="o">+</span> <span class="s">&quot;/Header&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">HeaderFile</span><span class="p">(</span><span class="n">HeaderFileName</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">::</span><span class="n">out</span>   <span class="o">|</span>
                                                     <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">::</span><span class="n">trunc</span> <span class="o">|</span>
                                                     <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span> <span class="n">HeaderFile</span><span class="p">.</span><span class="n">good</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">amrex</span><span class="o">::</span><span class="n">FileOpenFailed</span><span class="p">(</span><span class="n">HeaderFileName</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">HeaderFile</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">17</span><span class="p">);</span>

    <span class="n">VisMF</span><span class="o">::</span><span class="n">IO_Buffer</span> <span class="n">io_buffer</span><span class="p">(</span><span class="n">VisMF</span><span class="o">::</span><span class="n">IO_Buffer_Size</span><span class="p">);</span>
    <span class="n">HeaderFile</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pubsetbuf</span><span class="p">(</span><span class="n">io_buffer</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">io_buffer</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="c1">// write out title line</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Checkpoint file for AmrCoreAdv</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="c1">// write out finest_level</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="n">finest_level</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="c1">// write out array of istep</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">istep</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="n">istep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="c1">// write out array of dt</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dt</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="c1">// write out array of t_new</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_new</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="n">t_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="c1">// write the BoxArray at each level</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lev</span> <span class="o">&lt;=</span> <span class="n">finest_level</span><span class="p">;</span> <span class="o">++</span><span class="n">lev</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">boxArray</span><span class="p">(</span><span class="n">lev</span><span class="p">).</span><span class="n">writeOn</span><span class="p">(</span><span class="n">HeaderFile</span><span class="p">);</span>
        <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">VisMF</span></span></code> is a class that can be used to perform
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> I/O in parallel. How many processes are allowed to
perform I/O simultaneously can be set via</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VisMF</span><span class="o">::</span><span class="n">SetNOutFiles</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>  <span class="c1">// up to 64 processes, which is also the default.</span>
</pre></div>
</div>
<p>The optimal number is of course system dependent. The following code
shows how to write a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// write the MultiFab data to, e.g., chk00010/Level_0/</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lev</span> <span class="o">&lt;=</span> <span class="n">finest_level</span><span class="p">;</span> <span class="o">++</span><span class="n">lev</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VisMF</span><span class="o">::</span><span class="n">Write</span><span class="p">(</span><span class="n">phi_new</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span>
                 <span class="n">amrex</span><span class="o">::</span><span class="n">MultiFabFileFullPrefix</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">checkpointname</span><span class="p">,</span> <span class="s">&quot;Level_&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It should also be noted that all the
data including those in ghost cells are written/read by
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">VisMF</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Write</span></span><span class="operator"><span class="pre">/</span></span><span class="name"><span class="pre">Read</span></span></code>.</p>
<p>For reading the Header file, AMReX can have the I/O process
read the file from the disk and broadcast it to others as
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword type"><span class="pre">char</span></span><span class="operator"><span class="pre">&gt;</span></span></code>. Then all processes can read the information with
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">istringstream</span></span></code>. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">File</span><span class="p">(</span><span class="n">restart_chkfile</span> <span class="o">+</span> <span class="s">&quot;/Header&quot;</span><span class="p">);</span>

<span class="n">VisMF</span><span class="o">::</span><span class="n">IO_Buffer</span> <span class="n">io_buffer</span><span class="p">(</span><span class="n">VisMF</span><span class="o">::</span><span class="n">GetIOBufferSize</span><span class="p">());</span>

<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">fileCharPtr</span><span class="p">;</span>
<span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">ReadAndBcastFile</span><span class="p">(</span><span class="n">File</span><span class="p">,</span> <span class="n">fileCharPtr</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fileCharPtrString</span><span class="p">(</span><span class="n">fileCharPtr</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">is</span><span class="p">(</span><span class="n">fileCharPtrString</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">,</span> <span class="n">word</span><span class="p">;</span>

<span class="c1">// read in title line</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>

<span class="c1">// read in finest_level</span>
<span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">finest_level</span><span class="p">;</span>
<span class="n">GotoNextLine</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>

<span class="c1">// read in array of istep</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">lis</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">lis</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">istep</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// read in array of dt</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">lis</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">lis</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stod</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// read in array of t_new</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">lis</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">lis</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t_new</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stod</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following code how to read in a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>, create a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>, build <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FluxRegister</span></span></code> data,
and read in a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> from a checkpoint file, on a level-by-level basis:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lev</span> <span class="o">&lt;=</span> <span class="n">finest_level</span><span class="p">;</span> <span class="o">++</span><span class="n">lev</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// read in level &#39;lev&#39; BoxArray from Header</span>
    <span class="n">BoxArray</span> <span class="n">ba</span><span class="p">;</span>
    <span class="n">ba</span><span class="p">.</span><span class="n">readFrom</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
    <span class="n">GotoNextLine</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>

    <span class="c1">// create a distribution mapping</span>
    <span class="n">DistributionMapping</span> <span class="n">dm</span> <span class="p">{</span> <span class="n">ba</span><span class="p">,</span> <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">NProcs</span><span class="p">()</span> <span class="p">};</span>

    <span class="c1">// set BoxArray grids and DistributionMapping dmap in AMReX_AmrMesh.H class</span>
    <span class="n">SetBoxArray</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">ba</span><span class="p">);</span>
    <span class="n">SetDistributionMap</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">dm</span><span class="p">);</span>

    <span class="c1">// build MultiFab and FluxRegister data</span>
    <span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nghost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">phi_old</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">define</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">nghost</span><span class="p">);</span>
    <span class="n">phi_new</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">define</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">nghost</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lev</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">do_reflux</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flux_reg</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">FluxRegister</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">refRatio</span><span class="p">(</span><span class="n">lev</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">lev</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// read in the MultiFab data</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lev</span> <span class="o">&lt;=</span> <span class="n">finest_level</span><span class="p">;</span> <span class="o">++</span><span class="n">lev</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VisMF</span><span class="o">::</span><span class="n">Read</span><span class="p">(</span><span class="n">phi_new</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span>
                <span class="n">amrex</span><span class="o">::</span><span class="n">MultiFabFileFullPrefix</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">restart_chkfile</span><span class="p">,</span> <span class="s">&quot;Level_&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It should be emphasized that calling <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">VisMF</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Read</span></span></code> with an empty
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> (i.e., no memory allocated for floating point data)
will result in a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> with a new <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>
that could be different from any other existing
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> objects and is not recommended.</p>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Chapter7.html" class="btn btn-neutral float-right" title="Linear Solvers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Chapter6a.html" class="btn btn-neutral" title="I/O (Plotfile, Checkpoint)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, AMReX Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'18.03-dev',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>