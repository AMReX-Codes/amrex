subroutine integrate_ode(mf, lo, hi, cvode_meth, cvode_itmeth) bind(C, name="integrate_ode")

  use amrex_error_module
  use, intrinsic :: iso_c_binding

  implicit none

  integer, intent(in) :: lo(3),hi(3)
  real(c_double), intent(inout) :: mf(lo(1):hi(1), lo(2):hi(2), lo(3):hi(3))
  integer(c_int), intent(in) :: cvode_meth
  integer(c_int), intent(in) :: cvode_itmeth

  ! local variables
  integer i,j,k

  integer(c_long), parameter :: neq = 1 ! how many equations in the ODE system?
  integer(c_long) :: ipar(1)
  real(c_double) :: rpar(2)
  integer(c_long) :: iout(21) ! misc integer output parameters generated by CVODE
  real(c_double) :: rout(6) ! misc floating-point output parameters generated by CVODE
  integer :: ier ! CVODE return status
  integer(c_int) :: iatol, itask
  real(c_double) :: t_soln ! final time at the end of CVODE integration
  real(c_double) :: y(neq)
  real(c_double) :: atol, rtol(neq)
  real(c_double) :: t0, t1

  ! First arg tells fnvinit() that we are using it for CVODE, not for one of the other solvers in SUNDIALS
  call fnvinits(1, neq, ier)
  if (ier /= 0) call amrex_abort("integrate_ode: failed in fnvinits()")

  t0 = 0.0d0 ! initial time for integration
  t1 = 2.0d0 ! final time for integration

  y(1) = 0.0d0 ! initial conditions for the system of equations

  iatol = 1  ! 1 = scalar atol (1 atol for all eqns); 2 = vector atol (1 atol for each eqn)

  atol    = 1.0d-8
  rtol(1) = 1.0d-8

  ipar(1) = 42     ! Pass an arbitrary number of integer parameters into ipar
  rpar(1) = 42.0d0 ! Pass an arbitrary number of floating-point parameters into rpar

  itask = 1 ! 1 = Return from CVODE only after final integration time has been reached
            ! 2 = Return from CVODE after one integration step

  ! Set up CVODE solver machinery. This allocates a lot of memory. Since we will be solving the same system of ODEs in each cell and
  ! only changing initial conditions among cells, we don't want to allocate and deallocate all this stuff in each cell, because that
  ! will be slow (and unnecessary). So instead, we allocate the solver stuff once outside the (i,j,k) loop, and then within the
  ! (i,j,k) loop we just "re-initialize" the solver, which does not allocate any new data, but rather just sets up new initial
  ! conditions.
  call fcvmalloc(t0, y, cvode_meth, cvode_itmeth, iatol, rtol, atol, iout, rout, ipar, rpar, ier)
  if (ier /= 0) call amrex_abort("integrate_ode: failed in fcvmalloc()")

  ! Tell CVODE to use a dense linear solver.
  call fcvdense(neq, ier)
  if (ier /= 0) call amrex_abort("integrate_ode: failed in fcvdense()")

  do k=lo(3),hi(3)
     do j=lo(2),hi(2)
        do i=lo(1),hi(1)
           y(1) = real(i+j+k, c_double)
           call fcvreinit(t0, y, iatol, rtol, atol, ier)
           if (ier /= 0) call amrex_abort("integrate_ode: failed in fcvreinit()")
           call fcvode(t1, t_soln, y, itask, ier)
           if (ier /= 0) call amrex_abort("integrate_ode: failed in fcvode()")
           mf(i,j,k) = y(1)
        end do
     end do
  end do

  ! Deallocate memory allocated by fcvmalloc(). Don't know if this also frees the memory created in fnvinit, but the Fortran
  ! interface does not have a corresponding function.
  call fcvfree

end subroutine integrate_ode
