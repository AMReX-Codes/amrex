

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>HeatEquation_EX1_C Example &mdash; amrex 18.02-dev documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="amrex 18.02-dev documentation" href="index.html"/>
        <link rel="up" title="Basics" href="Chapter4.html"/>
        <link rel="next" title="Boundary Conditions" href="Boundary.html"/>
        <link rel="prev" title="Basics" href="Chapter4.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                18.02-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter2.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter3.html">Building AMReX</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Chapter4.html">Basics</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">HeatEquation_EX1_C Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dimensionality">Dimensionality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vector">Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="#real">Real</a></li>
<li class="toctree-l2"><a class="reference internal" href="#paralleldescriptor">ParallelDescriptor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#print">Print</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parmparse">ParmParse</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-amr-grids">Example of AMR Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="#box-intvect-and-indextype">Box, IntVect and IndexType</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#intvect">IntVect</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indextype">IndexType</a></li>
<li class="toctree-l3"><a class="reference internal" href="#box">Box</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#realbox-and-geometry">RealBox and Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boxarray">BoxArray</a></li>
<li class="toctree-l2"><a class="reference internal" href="#distributionmapping">DistributionMapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basefab-farraybox-and-iarraybox">BaseFab, FArrayBox and IArrayBox</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fabarray-multifab-and-imultifab">FabArray, MultiFab and iMultiFab</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mfiter-and-tiling">MFIter and Tiling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mfiter-without-tiling">MFIter without Tiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mfiter-with-tiling">MFIter with Tiling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#calling-fortran-or-c">Calling Fortran or C</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ghost-cells">Ghost Cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="#i-o">I/O</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plotfile">Plotfile</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checkpoint-file">Checkpoint File</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-allocation">Memory Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#abort-and-assertion">Abort and Assertion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Boundary.html">Boundary Conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter6.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter7.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter8.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter9.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter10.html">Embedded Boundaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter11.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter12.html">Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter13.html">CVODE</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="Chapter4.html">Basics</a> &raquo;</li>
        
      <li>HeatEquation_EX1_C Example</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="heatequation-ex1-c-example">
<h1>HeatEquation_EX1_C Example<a class="headerlink" href="#heatequation-ex1-c-example" title="Permalink to this headline">¶</a></h1>
<p>The source code tree for the heat equation example is simple, as shown in
<a class="reference internal" href="#fig-basics-heat-flowchart"><span class="std std-numref">Fig. 1</span></a>. We recommend you study
main.cpp and advance.cpp to see some of the classes described
below in action.</p>
<div class="figure" id="id1">
<span id="fig-basics-heat-flowchart"></span><a class="reference internal image-reference" href="_images/flowchart2.png"><img alt="_images/flowchart2.png" src="_images/flowchart2.png" style="width: 4in;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Source code tree for the HeatEquation_EX1_C example</span></p>
<div class="legend">
<blockquote>
<div><dl class="docutils">
<dt>amrex/Src/Base/</dt>
<dd>Contains source code for single-level simulations.</dd>
<dt>amrex/Tutorials/HeatEquation_EX1_C</dt>
<dd>Build the code here by editing the GNUmakefile and running make.</dd>
</dl>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="dimensionality">
<span id="sec-basics-dim"></span><h1>Dimensionality<a class="headerlink" href="#dimensionality" title="Permalink to this headline">¶</a></h1>
<p>As we have mentioned in <a class="reference internal" href="Chapter3.html#chap-buildingamrex"><span class="std std-ref">Building AMReX</span></a>, the
dimensionality of AMReX&nbsp;must be set at compile time. A macro,
<code class="docutils literal"><span class="pre">AMREX_SPACEDIM</span></code>, is defined to be the number of spatial
dimensions. C++ codes can also use the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">SpaceDim</span></span></code>
variable. Fortran codes can use either the macro and preprocessing or
do</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_spacedim</span>
</pre></div>
</div>
<p>The coordinate directions are zero based.</p>
</div>
<div class="section" id="vector">
<h1>Vector<a class="headerlink" href="#vector" title="Permalink to this headline">¶</a></h1>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span></code> class in AMReX_Vector.H is derived from
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">vector</span></span></code>. The only difference between <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span></code> and
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">vector</span></span></code> is that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">::</span></span><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code> provides bound checking
when compiled with <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DEBUG</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">TRUE</span></span></code>.</p>
</div>
<div class="section" id="real">
<h1>Real<a class="headerlink" href="#real" title="Permalink to this headline">¶</a></h1>
<p>AMReX&nbsp;can be compiled to use either double precision (which is the
default) or single precision. <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Real</span></span></code> is typedef’d to
either <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">double</span></span></code> or <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">float</span></span></code>. C codes can use
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex_real</span></span></code>. They are defined in AMReX_REAL.H. The data
type is accessible in Fortran codes via</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
</pre></div>
</div>
</div>
<div class="section" id="paralleldescriptor">
<span id="sec-basics-paralleldescriptor"></span><h1>ParallelDescriptor<a class="headerlink" href="#paralleldescriptor" title="Permalink to this headline">¶</a></h1>
<p>AMReX&nbsp;users do not need to use MPI directly. Parallel communication
is often handled by the data abstraction classes (e.g.,MultiFab; section
on <a class="reference internal" href="#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a>). In addition, AMReX&nbsp;has provided namespace
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParallelDescriptor</span></span></code> in <code class="docutils literal"><span class="pre">AMReX_ParallelDescriptor.H.</span></code> The frequently used
functions are</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">myproc</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">MyProc</span><span class="p">();</span>  <span class="c1">// Return the rank</span>

<span class="kt">int</span> <span class="n">nprocs</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">NProcs</span><span class="p">();</span>  <span class="c1">// Return the number of processes</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">IOProcessor</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Only the I/O process executes this</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">ioproc</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">IOProcessorNumber</span><span class="p">();</span>  <span class="c1">// I/O rank</span>

<span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">Barrier</span><span class="p">();</span>

<span class="c1">// Broadcast 100 ints from the I/O Processor</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">Bcast</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
                    <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">IOProcessorNumber</span><span class="p">())</span>

<span class="c1">// See AMReX_ParallelDescriptor.H for many other Reduce functions</span>
<span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">ReduceRealSum</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="print">
<span id="sec-basics-print"></span><h1>Print<a class="headerlink" href="#print" title="Permalink to this headline">¶</a></h1>
<p>AMReX&nbsp;provides classes in <code class="docutils literal"><span class="pre">AMReX_Print.H</span></code> for printing messages
to standard output or any C++&nbsp;<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ostream</span></span></code>. The main reason one
should use them instead of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">cout</span></span></code> is that messages from
multiple processes or threads do not get mixed up. Below are some
examples.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span>  <span class="s">&quot;x = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="c1">// Print on I/O processor</span>

<span class="n">Real</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atan</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="mf">4.0</span><span class="p">;</span>
<span class="c1">// Print on rank 3 with precision of 17 digits</span>
<span class="c1">// SetPrecision does not modify cout&#39;s floating-point decimal precision setting.</span>
<span class="n">Print</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">SetPrecision</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">oldprec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// Print with 10 digits</span>

<span class="n">AllPrint</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Every process prints</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// Print on every process</span>

<span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">ofs</span><span class="p">(</span><span class="s">&quot;my.txt&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
<span class="n">Print</span><span class="p">(</span><span class="n">ofs</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Print to a file&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">ofs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="parmparse">
<span id="sec-basics-parmparse"></span><h1>ParmParse<a class="headerlink" href="#parmparse" title="Permalink to this headline">¶</a></h1>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> in AMReX_ParmParse.H is a class providing a
database for the storage and retrieval of command-line and input-file
arguments. When <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Initialize</span></span><span class="punctuation"><span class="pre">()</span></span></code> is called, the first
command-line argument after the executable name (if there is one and
it does not contain character =) is taken to be the inputs file,
and the contents in the file are used to initialize the
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> database. The rest of the command-line arguments are
also parsed by <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code>. The format of the inputs file is a
series of definitions in the form of <code class="docutils literal"><span class="pre">prefix.name</span> <span class="pre">=</span> <span class="pre">value</span> <span class="pre">value</span>
<span class="pre">....</span></code> For each line, text after # are comments. Here is an
example inputs file.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">nsteps</span>    <span class="o">=</span> <span class="mi">100</span>               <span class="c1"># integer</span>
<span class="n">nsteps</span>    <span class="o">=</span> <span class="mi">1000</span>              <span class="c1"># nsteps appears a second time</span>
<span class="n">dt</span>        <span class="o">=</span> <span class="mf">0.03</span>              <span class="c1"># floating point number</span>
<span class="n">ncells</span>    <span class="o">=</span> <span class="mi">128</span> <span class="mi">64</span> <span class="mi">32</span>         <span class="c1"># a list of 3 ints</span>
<span class="nb">xrange</span>    <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="mf">0.5</span>          <span class="c1"># a list of 2 reals</span>
<span class="n">title</span>     <span class="o">=</span> <span class="s2">&quot;Three Kingdoms&quot;</span>  <span class="c1"># a string</span>
<span class="n">hydro</span><span class="o">.</span><span class="n">cfl</span> <span class="o">=</span> <span class="mf">0.8</span>               <span class="c1"># with prefix, hydro</span>
</pre></div>
</div>
</div></blockquote>
<p>The following code shows how to use <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> to get/query the values.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ParmParse</span> <span class="n">pp</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">nsteps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pp</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;nsteps&quot;</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">);</span>
<span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nsteps</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// 1000</span>

<span class="n">Real</span> <span class="n">dt</span><span class="p">;</span>
<span class="n">pp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;dt&quot;</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>  <span class="c1">// runtime error if dt is not in inputs</span>

<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numcells</span><span class="p">;</span>
<span class="c1">// The variable name &#39;numcells&#39; can be different from parameter name &#39;ncells&#39;.</span>
<span class="n">pp</span><span class="p">.</span><span class="n">getarr</span><span class="p">(</span><span class="s">&quot;ncells&quot;</span><span class="p">,</span> <span class="n">numcells</span><span class="p">);</span>
<span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">numcells</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// 3</span>

<span class="n">Vector</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="n">xr</span> <span class="p">{</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queryarr</span><span class="p">(</span><span class="s">&quot;xrange&quot;</span><span class="p">,</span> <span class="n">xr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cannot find xrange in inputs, &quot;</span>
                   <span class="o">&lt;&lt;</span> <span class="s">&quot;so the default {-1.0,1.0} will be used</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">;</span>
<span class="n">pp</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">,</span> <span class="n">title</span><span class="p">);</span>  <span class="c1">// query string</span>

<span class="n">ParmParse</span> <span class="nf">pph</span><span class="p">(</span><span class="s">&quot;hydro&quot;</span><span class="p">);</span>  <span class="c1">// with prefix &#39;hydro&#39;</span>
<span class="n">Real</span> <span class="n">cfl</span><span class="p">;</span>
<span class="n">pph</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;cfl&quot;</span><span class="p">,</span> <span class="n">cfl</span><span class="p">);</span>    <span class="c1">// get parameter with prefix</span>
</pre></div>
</div>
<p>Note that when there are multiple definitions for a parameter
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> by default returns the last one. The difference between
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">query</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">get</span></span></code> should also be noted. It is a runtime error
if <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">get</span></span></code> fails to get the value, whereas <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">query</span></span></code> returns an
error code without generating a runtime error that will abort the run.
If it is sometimes convenient to override parameters with command-line
arguments without modifying the inputs file. The command-line
arguments after the inputs file are added later than the file to the
database and are therefore used by default. For example, one can run
with</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">myexecutable myinputsfile ncells=&quot;64 32 16&quot; hydro.cfl=0.9</span>
</pre></div>
</div>
<p>to change the value of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ncells</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">hydro</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">cfl</span></span></code>.</p>
</div>
<div class="section" id="example-of-amr-grids">
<span id="sec-basics-amrgrids"></span><h1>Example of AMR Grids<a class="headerlink" href="#example-of-amr-grids" title="Permalink to this headline">¶</a></h1>
<p>In block-structured AMR, there is a hierarchy of logically rectangular
grids. The computational domain on each AMR level is decomposed into
a union of rectangular domains. <a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 2</span></a>
below shows an example of AMR with three total levels.
In the AMReX&nbsp;numbering convention, the coarsest level is
level 0. The coarsest grid (<em>black</em>) covers the domain with
<span class="math">\(16^2\)</span> cells. Bold lines represent grid boundaries. There are
two intermediate resolution grids (<em>blue</em>) at level 1 and the
cells are a factor of two finer than those at level 0. The two finest
grids (<em>red</em>) are at level 2 and the cells are a factor of two
finer than the level 1 cells. There are 1, 2 and 2 Boxes on levels
0, 1, and 2, respectively. Note that there is no direct
parent-child connection. In this chapter, we will focus on single
levels.</p>
<div class="figure" id="id2">
<span id="fig-basics-amrgrids"></span><a class="reference internal image-reference" href="_images/amrgrids.png"><img alt="_images/amrgrids.png" src="_images/amrgrids.png" style="width: 3in;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Example of AMR grids. There are three levels in total.
There are 1, 2 and 2 Boxes on levels 0, 1, and 2, respectively.</span></p>
</div>
</div>
<div class="section" id="box-intvect-and-indextype">
<span id="sec-basics-box"></span><h1>Box, IntVect and IndexType<a class="headerlink" href="#box-intvect-and-indextype" title="Permalink to this headline">¶</a></h1>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> in AMReX_Box.H is the data structure for representing
a rectangular domain in indexing space.
In <a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 2</span></a>,
there are 1, 2 and 2 Boxes on levels 0, 1 and 2, respectively.
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> is a dimension-dependent class. It has lower and upper corners
(represented by <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code>) and an index type (represented by
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IndexType</span></span></code>). A :cpp`Box` contains no floating-point data.</p>
<div class="section" id="intvect">
<h2>IntVect<a class="headerlink" href="#intvect" title="Permalink to this headline">¶</a></h2>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVec</span></span></code> is a dimension-dependent class representing an
integer vector in <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">AMREX</span></span> <span class="name"><span class="pre">SPACEDIM</span></span></code>-dimensional space. An
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code> can be constructed as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">AMREX_D_DECL</span></span></code> is a macro that expands
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">AMREX_D_DECL</span></span><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">19</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">5</span></span><span class="punctuation"><span class="pre">)</span></span></code> to either <code class="code cpp c++ docutils literal"><span class="literal number integer"><span class="pre">19</span></span></code> or <code class="code cpp c++ docutils literal"><span class="literal number integer"><span class="pre">19</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="literal number integer"><span class="pre">0</span></span></code> or
<code class="code cpp c++ docutils literal"><span class="literal number integer"><span class="pre">19</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="literal number integer"><span class="pre">5</span></span></code> depending on the number of dimensions. The data can be
accessed via <code class="code cpp c++ docutils literal"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code>, and the internal data pointer can be
returned by function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">getVect</span></span></code>. For example</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idim</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="o">++</span><span class="n">idim</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;iv[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">idim</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">iv</span><span class="p">.</span><span class="n">getVect</span><span class="p">();</span>  <span class="c1">// This can be passed to Fortran/C as an array</span>
</pre></div>
</div>
<p>The class has a static function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">TheZeroVector</span></span><span class="punctuation"><span class="pre">()</span></span></code> returning the
zero vector, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">TheUnitVector</span></span><span class="punctuation"><span class="pre">()</span></span></code> returning the unit vector, and
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">TheDimensionVector</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">dir</span></span><span class="punctuation"><span class="pre">)</span></span></code> returning a reference to a constant
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code> that is zero except in the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">dir</span></span></code>-direction. Note
the direction is zero-based. <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code> has a number of relational
operators, <code class="code cpp c++ docutils literal"><span class="operator"><span class="pre">==</span></span></code>, <code class="code cpp c++ docutils literal"><span class="operator"><span class="pre">!=</span></span></code>, <code class="code cpp c++ docutils literal"><span class="operator"><span class="pre">&lt;</span></span></code>, <code class="code cpp c++ docutils literal"><span class="operator"><span class="pre">&lt;=</span></span></code>, <code class="code cpp c++ docutils literal"><span class="operator"><span class="pre">&gt;</span></span></code> , and
<code class="code cpp c++ docutils literal"><span class="operator"><span class="pre">&gt;=</span></span></code> that can be used for lexicographical comparison (e.g., key of
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">map</span></span></code>), and a class <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">shift_hasher</span></span></code> that can be
used as a hash function (e.g., for <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">unordered_map</span></span></code>). It
also has various arithmetic operators. For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="nf">iv2</span><span class="p">((</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="n">iv</span> <span class="o">+=</span> <span class="n">iv2</span><span class="p">;</span>  <span class="c1">// iv is now (23,8,5)</span>
<span class="n">iv</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">// iv is now (46,16,10);</span>
</pre></div>
</div>
<p>In AMR codes, one often needs to do refinement and coarsening on
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code>. The refinement operation can be done with the
multiplication operation. However, the coarsening requires care
because of the rounding towards zero behavior of integer division in
Fortran, C and C++. For example <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">i</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">-</span></span><span class="literal number integer"><span class="pre">1</span></span><span class="operator"><span class="pre">/</span></span><span class="literal number integer"><span class="pre">2</span></span></code> gives <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">i</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">0</span></span></code>,
and what we want is usually <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">i</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">-</span></span><span class="literal number integer"><span class="pre">1</span></span></code>. Thus, one should use
the coarsen functions:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="nf">coarsening_ratio</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
<span class="n">iv</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>                 <span class="c1">// Coarsen each component by 2</span>
<span class="n">iv</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="n">coarsening_ratio</span><span class="p">);</span>  <span class="c1">// Component-wise coarsening</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">iv2</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">coarsen</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Return an IntVect w/o modifying iv</span>
<span class="n">IntVect</span> <span class="n">iv3</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">coarsen</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">coarsening_return</span><span class="p">);</span> <span class="c1">// iv not modified</span>
</pre></div>
</div>
<p>Finally, we note that <code class="code cpp c++ docutils literal"><span class="keyword"><span class="pre">operator</span></span><span class="operator"><span class="pre">&lt;&lt;</span></span></code> is overloaded for
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code> and therefore one can call</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="indextype">
<h2>IndexType<a class="headerlink" href="#indextype" title="Permalink to this headline">¶</a></h2>
<p>This class defines an index as being cell based or node based in
each dimension. The default constructor defines a cell based type in
all directions. One can also construct an <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IndexType</span></span></code> with an
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code> with zero and one representing cell and node,
respectively.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Node in x-direction and cell based in y and z-directions</span>
<span class="c1">// (i.e., x-face of numerical cells)</span>
<span class="n">IndexType</span> <span class="nf">xface</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)});</span>
</pre></div>
</div>
<p>The class provides various functions including</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// True if the IndexType is cell based in all directions.</span>
<span class="kt">bool</span> <span class="nf">cellCentered</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// True if the IndexType is cell based in dir-direction.</span>
<span class="kt">bool</span> <span class="nf">cellCentered</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dir</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// True if the IndexType is node based in all directions.</span>
<span class="kt">bool</span> <span class="nf">nodeCentered</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// True if the IndexType is node based in dir-direction.</span>
<span class="kt">bool</span> <span class="nf">nodeCentered</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dir</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Index type is a very important concept in AMReX. It is a way of
representing the notion of indices <span class="math">\(i\)</span> and <span class="math">\(i+1/2\)</span>.</p>
</div>
<div class="section" id="box">
<h2>Box<a class="headerlink" href="#box" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal"><span class="pre">Box</span></code> is an abstraction for defining discrete regions of
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">AMREX_SPACEDIM</span></span></code>-dimensional indexing space. Boxes have an
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IndexType</span></span></code> and two <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVects</span></span></code> representing the lower and
upper corners. Boxes can exist in positive and negative indexing
space. Typical ways of defining a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> are</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">lo</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="nf">hi</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">));</span>
<span class="n">IndexType</span> <span class="nf">typ</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)});</span>
<span class="n">Box</span> <span class="nf">cc</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="p">);</span>        <span class="c1">// By default, Box is cell based.</span>
<span class="n">Box</span> <span class="nf">nd</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">typ</span><span class="p">);</span>  <span class="c1">// Construct a nodal Box.</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;A cell-centered Box &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cc</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;An all nodal Box    &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nd</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Depending the dimensionality, the output of the code above is</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">cell</span><span class="o">-</span><span class="n">centered</span> <span class="n">Box</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">An</span> <span class="n">all</span> <span class="n">nodal</span> <span class="n">Box</span>    <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>For simplicity, we will assume it is 3D for the rest of this section.
In the output, three integer tuples for each box are the lower corner
indices, upper corner indices, and the index types. Note that 0
and 1 denote cell and node, respectively. For each tuple like
<code class="code cpp c++ docutils literal"><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">)</span></span></code>, the 3 numbers are for 3 directions. The two
Boxes in the code above represent different indexing views of the
same domain of <span class="math">\(64^3\)</span> cells. Note that in AMReX&nbsp;convention, the
lower side of a cell has the same integer value as the cell centered
index. That is if we consider a cell based index represent <span class="math">\(i\)</span>, the
nodal index with the same integer value represents <span class="math">\(i-1/2\)</span>.
<a class="reference internal" href="#fig-basics-indextypes"><span class="std std-numref">Fig. 3</span></a> shows some of the different index types for 2D.</p>
<div class="figure" id="id3">
<span id="fig-basics-indextypes"></span><a class="reference internal image-reference" href="_images/indextypes.png"><img alt="_images/indextypes.png" src="_images/indextypes.png" style="width: 5in;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Some of the different index types in two dimensions: (a) cell-centered, (b) <span class="math">\(x\)</span>-face-centered
(i.e., nodal in <span class="math">\(x\)</span>-direction only), and (c) corner/nodal,
i.e., nodal in all dimensions.</span></p>
</div>
<p>There are a number of ways of converting a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> from one type to
another.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">b0</span> <span class="p">({</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">},</span> <span class="p">{</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">});</span> <span class="c1">// Index type: (cell, cell, cell)</span>

<span class="n">Box</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">surroundingNodes</span><span class="p">(</span><span class="n">b0</span><span class="p">);</span>  <span class="c1">// A new Box with type (node, node, node)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b1</span><span class="p">;</span>                  <span class="c1">// ((64,64,64) (128,128,128) (1,1,1))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b0</span><span class="p">;</span>                  <span class="c1">// Still ((64,64,64) (127,127,127) (0,0,0))</span>

<span class="n">Box</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">enclosedCells</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>     <span class="c1">// A new Box with type (cell, cell, cell)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">b2</span> <span class="o">==</span> <span class="n">b0</span><span class="p">)</span> <span class="p">{</span>                 <span class="c1">// Yes, they are identical.</span>
   <span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;b0 and b2 are identical!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Box</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>  <span class="c1">// A new Box with type (cell, node, cell)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b3</span><span class="p">;</span>                  <span class="c1">// ((64,64,64) (127,128,127) (0,1,0))</span>

<span class="n">b3</span><span class="p">.</span><span class="n">convert</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>            <span class="c1">// Convert b0 to type (cell, cell, node)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b3</span><span class="p">;</span>                  <span class="c1">// ((64,64,64) (127,127,128) (0,0,1))</span>

<span class="n">b3</span><span class="p">.</span><span class="n">surroundingNodes</span><span class="p">();</span>          <span class="c1">//  Exercise for you</span>
<span class="n">b3</span><span class="p">.</span><span class="n">enclosedCells</span><span class="p">();</span>             <span class="c1">//  Exercise for you</span>
</pre></div>
</div>
<p>The internal data of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> can be accessed via various member functions.
Examples are</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">smallEnd</span> <span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>  <span class="c1">// Get the small end of the Box</span>
<span class="kt">int</span> <span class="nf">bigEnd</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dir</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>         <span class="c1">// Get the big end in dir direction</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">loVect</span> <span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>        <span class="c1">// Get a const pointer to the lower end</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">hiVect</span> <span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>        <span class="c1">// Get a const pointer to the upper end</span>
</pre></div>
</div>
<p>Boxes can be refined and coarsened. Refinement or coarsening
does not change the index type. Some examples are shown below.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">ccbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">});</span>
<span class="n">ccbx</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ccbx</span><span class="p">;</span>                   <span class="c1">// ((32,32,32) (63,63,63) (0,0,0))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ccbx</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>        <span class="c1">// ((16,16,16) (31,31,31) (0,0,0))</span>

<span class="n">Box</span> <span class="nf">ndbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">ndbx</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ndbx</span><span class="p">;</span>                   <span class="c1">// ((32,32,32) (64,64,64) (1,1,1))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ndbx</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>        <span class="c1">// ((16,16,16) (32,32,32) (1,1,1))</span>

<span class="n">Box</span> <span class="nf">facebx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>
<span class="n">facebx</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">facebx</span><span class="p">;</span>                 <span class="c1">// ((32,32,32) (64,63,63) (1,0,0))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">facebx</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>      <span class="c1">// ((16,16,16) (32,31,31) (1,0,0))</span>

<span class="n">Box</span> <span class="nf">uncoarsenable</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">});</span>
<span class="n">print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">uncoarsenable</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// ({8,8,8}, {15,15,15});</span>
<span class="n">print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">uncoarsenable</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// ({16,16,16}, {31,31,31});</span>
                                     <span class="c1">// Different from the original!</span>
</pre></div>
</div>
<p>Note that the behavior of refinement and coarsening depends on the index
type. Note that in this context, the refined or coarsened <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> still
covers the same physical domain. <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span> <span class="name"><span class="pre">uncoarsenable</span></span></code> in the example above
is considered uncoarsenable because its coarsened version does not cover the same
physical domain in the AMR context.</p>
<p>Boxes can grow in one or all directions.  There are a number of grow functions.
Some are member functions of the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> class and others are non-member
functions in the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span></code> namespace.</p>
<p>The <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> class provides the following member functions testing if a
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> or <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code> is contained within this <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code>. Note that
it is a runtime error if the two Boxes have different types.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">contains</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">strictly_contains</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">contains</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">strictly_contains</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Another very common operation is the intersection of two Boxes
like in the following examples.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">b0</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">});</span>
<span class="n">Box</span> <span class="nf">b1</span> <span class="p">({</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">},</span> <span class="p">{</span><span class="mi">23</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">63</span><span class="p">});</span>
<span class="k">if</span> <span class="p">(</span><span class="n">b0</span><span class="p">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span> <span class="p">{</span>                  <span class="c1">// true</span>
    <span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;b0 and b1 intersect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Box</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">&amp;</span> <span class="n">b1</span><span class="p">;</span>     <span class="c1">// b0 and b1 unchanged</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b2</span><span class="p">;</span>        <span class="c1">// ((16,16,30) (23,23,31) (0,0,0))</span>

<span class="n">Box</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">surroundingNodes</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">surroundingNodes</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span> <span class="c1">// b0 and b1 unchanged</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b3</span><span class="p">;</span>        <span class="c1">// ((16,16,30) (24,24,32) (1,1,1))</span>

<span class="n">b0</span> <span class="o">&amp;=</span> <span class="n">b2</span><span class="p">;</span>             <span class="c1">// b2 unchanged</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b0</span><span class="p">;</span>        <span class="c1">// ((16,16,30) (23,23,31) (0,0,0))</span>

<span class="n">b0</span> <span class="o">&amp;=</span> <span class="n">b3</span><span class="p">;</span>             <span class="c1">// Runtime error because of type mismatch!</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="realbox-and-geometry">
<h1>RealBox and Geometry<a class="headerlink" href="#realbox-and-geometry" title="Permalink to this headline">¶</a></h1>
<p>A <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">RealBox</span></span></code> stores the physical location in floating-point numbers
of the lower and upper corners of a rectangular domain.</p>
<p>The <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Geometry</span></span></code> class in AMReX_Geometry.H describes problem
domain and coordinate system for rectangular problem domains. A
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Geometry</span></span></code> object can be constructed with</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">explicit</span> <span class="nf">Geometry</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span>     <span class="n">dom</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">RealBox</span><span class="o">*</span> <span class="n">rb</span>     <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span>
                      <span class="kt">int</span>            <span class="n">coord</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                      <span class="kt">int</span><span class="o">*</span>           <span class="n">is_per</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the constructor takes a cell-centered <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> specifying the
indexing space domain, an optional argument of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">RealBox</span></span></code> pointer
specifying the physical domain, an optional <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span></code> specifying
coordinate system type, and an optional <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code> specifying
periodicity. If a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">RealBox</span></span></code> is not given, AMReX&nbsp;will construct
one based on <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> parameters, <code class="docutils literal"><span class="pre">geometry.prob_lo</span></code> and
<code class="docutils literal"><span class="pre">geometry.prob_hi</span></code>, where each of the parameter is an array of
<code class="docutils literal"><span class="pre">AMREX_SPACEDIM</span></code> real numbers. It’s a runtime error if this
fails. The optional argument for coordinate system is an integer type
with valid values being 0 (Cartesian), or 1 (cylindrical), or 2
(spherical). If it is invalid as in the case of the default argument
value, AMReX&nbsp;will query the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> database for
<code class="docutils literal"><span class="pre">geometry.coord_sys</span></code> and use it if one is found. If it cannot find
the parameter, the coordinate system is set to 0 (i.e., Cartesian
coordinates). The <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Geometry</span></span></code> class has the concept of periodicity.
An optional argument can be passed specifying periodicity in each
dimension. If it is not given, the domain is assumed to be
non-periodic unless there is the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> integer array
parameter <code class="docutils literal"><span class="pre">geometry.is_periodic</span></code> with 0 denoting
non-periodic and 1 denoting periodic. Below is an example of
defining a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Geometry</span></span></code> for a periodic rectangular domain of
<span class="math">\([-1.0,1.0]\)</span> in each direction discretized with <span class="math">\(64\)</span> numerical cells
in each direction.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">n_cell</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="c1">// This defines a Box with n_cell cells in each direction.</span>
<span class="n">Box</span> <span class="nf">domain</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span>       <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">)},</span>
           <span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">)});</span>

<span class="c1">// This defines the physical box, [-1,1] in each direction.</span>
<span class="n">RealBox</span> <span class="nf">real_box</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)},</span>
                 <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)});</span>

<span class="c1">// This says we are using Cartesian coordinates</span>
<span class="kt">int</span> <span class="n">coord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// This sets the boundary conditions to be doubly or triply periodic</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">is_periodic</span> <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)};</span>

<span class="c1">// This defines a Geometry object</span>
<span class="n">Geometry</span> <span class="nf">geom</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">real_box</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">is_periodic</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</pre></div>
</div>
<p>A <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Geometry</span></span></code> object can return various information of the physical
domain and the indexing space domain. For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Real</span><span class="o">*</span> <span class="n">problo</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">ProbLo</span><span class="p">();</span>    <span class="c1">// Lower corner of the physical domain</span>
<span class="n">Real</span> <span class="n">yhi</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">ProbHi</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>             <span class="c1">// y-direction upper corner</span>
<span class="k">const</span> <span class="n">Real</span><span class="o">*</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">CellSize</span><span class="p">();</span>      <span class="c1">// Cell size for each direction</span>
<span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">Domain</span><span class="p">();</span>     <span class="c1">// Index domain</span>
<span class="kt">bool</span> <span class="n">is_per</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">::</span><span class="n">isPeriodic</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Is periodic in x-direction?</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Geometry</span><span class="o">::</span><span class="n">isAllPeriodic</span><span class="p">())</span> <span class="p">{}</span>      <span class="c1">// Periodic in all direction?</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Geometry</span><span class="o">::</span><span class="n">isAnyPeriodic</span><span class="p">())</span> <span class="p">{}</span>      <span class="c1">// Periodic in any direction?</span>
</pre></div>
</div>
</div>
<div class="section" id="boxarray">
<span id="sec-basics-ba"></span><h1>BoxArray<a class="headerlink" href="#boxarray" title="Permalink to this headline">¶</a></h1>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> is a class in <code class="docutils literal"><span class="pre">AMReX_BoxArray.H</span></code> for storing a
collection of Boxes on a single AMR level. One can make a
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> out of a single <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> and then chop it into multiple
Boxes.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">domain</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">});</span>
<span class="n">BoxArray</span> <span class="nf">ba</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>  <span class="c1">// Make a new BoxArray out of a single Box</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;BoxArray size is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ba</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// 1</span>
<span class="n">ba</span><span class="p">.</span><span class="n">maxSize</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>       <span class="c1">// Chop into boxes of 64^3 cells</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ba</span><span class="p">;</span>
</pre></div>
</div>
<p>The output is like below,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">BoxArray</span> <span class="n">maxbox</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
       <span class="n">m_ref</span><span class="o">-&gt;</span><span class="n">m_hash_sig</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>It shows that ba now has 8 Boxes, and it also prints out each Box.</p>
<p>In AMReX, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> is a global data structure. It holds all
the Boxes in a collection, even though a single process in a
parallel run only owns some of the Boxes via domain
decomposition. In the example above, a 4-process run may divide the
work and each process owns say 2 Boxes
(cf section on&nbsp;<a class="reference internal" href="#sec-basics-dm"><span class="std std-ref">DistributionMapping</span></a>). Each process can then allocate memory
for the floating point data on the Boxes it owns
(cf sections on&nbsp;<a class="reference internal" href="#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a> &amp; <a class="reference internal" href="#sec-basics-fab"><span class="std std-ref">BaseFab, FArrayBox and IArrayBox</span></a>).</p>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> has an indexing type, just like <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code>. Each
Box in a BoxArray has the same type as the BoxArray
itself. In the following example, we show how one can convert
BoxArray to a different type.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BoxArray</span> <span class="nf">cellba</span><span class="p">(</span><span class="n">Box</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">}));</span>
<span class="n">cellba</span><span class="p">.</span><span class="n">maxSize</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="n">BoxArray</span> <span class="n">faceba</span> <span class="o">=</span> <span class="n">cellba</span><span class="p">;</span>       <span class="c1">// Make a copy</span>
<span class="n">faceba</span><span class="p">.</span><span class="n">convert</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span> <span class="c1">// convert to index type (cell, cell, node)</span>
<span class="c1">// Return an all node BoxArray</span>
<span class="k">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">nodeba</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">faceba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">cellba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// ((0,0,0) (63,63,63) (0,0,0))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">faceba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// ((0,0,0) (63,63,64) (0,0,1))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nodeba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// ((0,0,0) (64,64,64) (1,1,1))</span>
</pre></div>
</div>
<p>As shown in the example above, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> has an <code class="code cpp c++ docutils literal"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code>
that returns a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> given an index. It should be emphasized that
there is a difference between its behavior and the usual behavior of
an subscript operator one might expect. The subscript operator in
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> returns by <strong>value instead of reference</strong>. This means code
like below is meaningless because it modifies a temporary return
value.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ba</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// DO NOT DO THIS!  Doesn&#39;t do what one might expect.</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> has a number of member functions that allow the
Boxes to be modified. For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">refine</span> <span class="p">(</span><span class="kt">int</span> <span class="n">refinement_ratio</span><span class="p">);</span>   <span class="c1">// Refine each Box in BoxArray</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">refine</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">refinement_ratio</span><span class="p">);</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">coarsen</span> <span class="p">(</span><span class="kt">int</span> <span class="n">refinement_ratio</span><span class="p">);</span>  <span class="c1">// Coarsen each Box in BoxArray</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">coarsen</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">refinement_ratio</span><span class="p">);</span>
</pre></div>
</div>
<p>We have mentioned at the beginning of this section that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>
is a global data structure storing Boxes shared by all processes.
The operation of a deep copy is thus undesirable because it
is expensive and the extra copy wastes memory. The
implementation of the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> class uses <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">shared_ptr</span></span></code>
to an internal container holding the actual Box data. Thus
making a copy of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> is a quite cheap operation. The
conversion of types and coarsening are also cheap because they can
share the internal data with the original <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>. In our
implementation, function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">refine</span></span></code> does create a new deep copy of the
original data. Also note that a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> and its variant with a
different type share the same internal data is an implementation detail.
We discuss this so that the users are aware of the performance and resource
cost. Conceptually we can think of them as completely independent of each
other.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BoxArray</span> <span class="nf">ba</span><span class="p">(...);</span>  <span class="c1">// original BoxArray</span>
<span class="n">BoxArray</span> <span class="n">ba2</span> <span class="o">=</span> <span class="n">ba</span><span class="p">;</span> <span class="c1">// a copy that shares the internal data with the original</span>
<span class="n">ba2</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>    <span class="c1">// Modify the copy</span>
<span class="c1">// The original copy is unmodified even though they share internal data.</span>
</pre></div>
</div>
<p>For advanced users, AMReX&nbsp;provides functions performing the
intersection of a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> and a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code>. These functions are
much faster than a naive implementation of performing intersection of
the Box with each Box in the BoxArray. If one needs
to perform those intersections, functions <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">intersect</span></span></code>,
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">intersects</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">intersections</span></span></code> should be
used.</p>
</div>
<div class="section" id="distributionmapping">
<span id="sec-basics-dm"></span><h1>DistributionMapping<a class="headerlink" href="#distributionmapping" title="Permalink to this headline">¶</a></h1>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code> is a class in
<code class="docutils literal"><span class="pre">AMReX_DistributionMapping.H</span></code> that describes which process owns the data
living on the domains specified by the Boxes in a
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>. Like <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>, there is an element for each
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> in <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code>, including the ones owned by other
parallel processes. One can construct a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code>
object given a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span> <span class="p">{</span><span class="n">ba</span><span class="p">};</span>
</pre></div>
</div>
<p>or by simply making a copy,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span> <span class="p">{</span><span class="n">another_dm</span><span class="p">};</span>
</pre></div>
</div>
<p>Note that this class is built using <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">shared_ptr</span></span></code>. Thus
making a copy is relatively cheap in terms of performance and memory
resources. This class has a subscript operator that returns the
process ID at a given index.</p>
<p>By default, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code> uses an algorithm based on space
filling curve to determine the distribution. One can change the default
via the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> parameter <code class="docutils literal"><span class="pre">DistributionMapping.strategy</span></code>.
<code class="docutils literal"><span class="pre">KNAPSACK</span></code> is a common choice that is optimized for load balance.
One can also explicitly construct a distribution.
The <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code> class allows the user to have complete control by
passing an array of integers that represent the mapping of grids to processes.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span><span class="p">;</span>   <span class="c1">// empty object</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pmap</span> <span class="p">{...};</span>
<span class="c1">// The user fills the pmap array with the values specifying owner processes</span>
<span class="n">dm</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="n">pmap</span><span class="p">);</span>  <span class="c1">// Build DistributionMapping given an array of process IDs.</span>
</pre></div>
</div>
</div>
<div class="section" id="basefab-farraybox-and-iarraybox">
<span id="sec-basics-fab"></span><h1>BaseFab, FArrayBox and IArrayBox<a class="headerlink" href="#basefab-farraybox-and-iarraybox" title="Permalink to this headline">¶</a></h1>
<p>AMReX&nbsp;is a block-structured AMR framework. Although AMR introduces
irregularity to the data and algorithms, there is regularity at the
block/Box level because each is still logically rectangular,
and the data structure
at the Box level is conceptually simple. <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code> is a
class template for multi-dimensional array-like data structure on a
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code>. The template parameter is typically basic types such as
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Real</span></span></code>, <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span></code> or <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">char</span></span></code>. The dimensionality of the array
is <code class="docutils literal"><span class="pre">AMREX_SPACEDIM</span></code> <em>plus one</em>. The additional dimension is for
the number of components. The data are internally stored in a
contiguous block of memory in Fortran array order (i.e., column-major
order) for <span class="math">\((x,y,z,\mathrm{component})\)</span>, and each component also
occupies a contiguous block of memory because of the ordering. For
example, a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">Real</span></span><span class="operator"><span class="pre">&gt;</span></span></code> with 4 components defined on a
three-dimensional <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">IntVect</span></span><span class="punctuation"><span class="pre">{</span></span><span class="operator"><span class="pre">-</span></span><span class="literal number integer"><span class="pre">4</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">32</span></span><span class="punctuation"><span class="pre">},</span></span><span class="name"><span class="pre">IntVect</span></span><span class="punctuation"><span class="pre">{</span></span><span class="literal number integer"><span class="pre">32</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">48</span></span><span class="punctuation"><span class="pre">})</span></span></code> is
like a Fortran array of <code class="code fortran docutils literal"><span class="keyword type"><span class="pre">real</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">amrex_real</span></span><span class="punctuation"><span class="pre">),</span></span> <span class="keyword"><span class="pre">dimension</span></span><span class="punctuation"><span class="pre">(</span></span><span class="operator"><span class="pre">-</span></span><span class="literal number integer"><span class="pre">4</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">32</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">32</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">48</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">3</span></span><span class="punctuation"><span class="pre">)</span></span></code>.
Note that the convention in C++&nbsp;part of AMReX&nbsp;is the component index is
zero based. The code for constructing such an object is as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">bx</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">48</span><span class="p">});</span>
<span class="kt">int</span> <span class="n">numcomps</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="n">fab</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span><span class="n">numcomps</span><span class="p">);</span>
</pre></div>
</div>
<p>Most applications do not use <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code> directly, but utilize
specialized classes derived from <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code>. The most common types
are <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> in AMReX_FArrayBox.H derived from
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">Real</span></span><span class="operator"><span class="pre">&gt;</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IArrayBox</span></span></code> in AMReX_IArrayBox.H
derived from <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword type"><span class="pre">int</span></span><span class="operator"><span class="pre">&gt;</span></span></code>.</p>
<p>These derived classes also obtain many <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code> member functions
via inheritance. We now show some common usages of these functions.
To get the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> where a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code> or its derived object is
defined, one can call</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>To the number of component, one can call</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">nComp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>To get a pointer to the array data, one can call</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">*</span> <span class="nf">dataPtr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>     <span class="c1">// Data pointer to the nth component</span>
                         <span class="c1">// T is template parameter (e.g., Real)</span>
<span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="nf">dataPtr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// const version</span>
</pre></div>
</div>
<p>The typical usage of the returned pointer is then to pass it to a
Fortran or C function that works on the array data (see the
section&nbsp;on <a class="reference internal" href="#sec-basics-fortran"><span class="std std-ref">Calling Fortran or C</span></a>).
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code> has several functions that set the array data to a
constant value (e.g., 0). Two examples are as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">);</span>        <span class="c1">// Set all data to x</span>
<span class="c1">// Set the sub-region specified by bx to value x starting from component</span>
<span class="c1">// nstart.  ncomp is the total number of component to be set.</span>
<span class="kt">void</span> <span class="nf">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nstart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">);</span>
</pre></div>
</div>
<p>One can copy data from one <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code> to another.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">copy</span> <span class="p">(</span><span class="k">const</span> <span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">srcbox</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srccomp</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">destbox</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destcomp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numcomp</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the function copies the data from the region specified by
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">srcbox</span></span></code> in the source <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span> <span class="name"><span class="pre">src</span></span></code> into the region specified by
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">destbox</span></span></code> in the destination BaseFab that invokes the
function call. Note that although <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">srcbox</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">destbox</span></span></code> may
be different, they must be the same size, shape and index type,
otherwise a runtime error occurs. The user also specifies how many
components (<code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">numcomp</span></span></code>) are copied starting at component
srccomp in src and stored starting at component
destcomp. BaseFab has functions returning the minimum or
maximum value.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="nf">min</span> <span class="p">(</span><span class="kt">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// Minimum value of given component.</span>
<span class="n">T</span> <span class="nf">min</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">subbox</span><span class="p">,</span> <span class="kt">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// Minimum value of given</span>
                                             <span class="c1">// component in given subbox.</span>
<span class="n">T</span> <span class="nf">max</span> <span class="p">(</span><span class="kt">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// Maximum value of given component.</span>
<span class="n">T</span> <span class="nf">max</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">subbox</span><span class="p">,</span> <span class="kt">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// Maximum value of given</span>
                                             <span class="c1">// component in given subbox.</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code> also has many arithmetic functions. Here are some
examples using FArrayBox.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">box</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">});</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">FArrayBox</span> <span class="nf">fab1</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">);</span>
<span class="n">FArrayBox</span> <span class="nf">fab2</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">);</span>
<span class="n">fab1</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>    <span class="c1">// Fill fab1 with 1.0</span>
<span class="n">fab1</span><span class="p">.</span><span class="n">mult</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// Multiply component 0 by 10.0</span>
<span class="n">fab2</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>    <span class="c1">// Fill fab2 with 2.0</span>
<span class="n">Real</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
<span class="n">fab2</span><span class="p">.</span><span class="n">saxpy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fab1</span><span class="p">);</span> <span class="c1">// For both components, fab2 &lt;- a * fab1 + fab2</span>
</pre></div>
</div>
<p>For more complicated expressions that not supported, one can write
Fortran or C functions for those (see the section on&nbsp;<a class="reference internal" href="#sec-basics-fortran"><span class="std std-ref">Calling Fortran or C</span></a>).
Note that BaseFab does provide operators for accessing the
data directly in C++. For example, the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">saxpy</span></span></code> example above can
be done with</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Iterate over all components</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">icomp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">icomp</span> <span class="o">&lt;</span> <span class="n">fab1</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span> <span class="o">++</span><span class="n">icomp</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Iterate over all cells in Box</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">BoxIterator</span> <span class="n">bit</span><span class="p">(</span><span class="n">fab1</span><span class="p">.</span><span class="n">box</span><span class="p">());</span> <span class="n">bit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// bit() returns IntVect</span>
        <span class="n">fab2</span><span class="p">(</span><span class="n">bit</span><span class="p">(),</span><span class="n">icomp</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">fab1</span><span class="p">(</span><span class="n">bit</span><span class="p">(),</span><span class="n">icomp</span><span class="p">)</span> <span class="o">+</span> <span class="n">fab2</span><span class="p">(</span><span class="n">bit</span><span class="p">(),</span><span class="n">icomp</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But this approach is generally not recommended for performance reason.
However, it can be handy for debugging.</p>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span></code> and its derived classes are containers for data on
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code>. We recall that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> has types (see the section on&nbsp;<a class="reference internal" href="#sec-basics-box"><span class="std std-ref">Box, IntVect and IndexType</span></a>).
The examples in this section so far use the default cell based type.
However, some functions will result in a runtime error if the types mismatch.
For example.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">ccbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">});</span>           <span class="c1">// cell centered box</span>
<span class="n">Box</span> <span class="nf">ndbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>  <span class="c1">// nodal box</span>
<span class="n">FArrayBox</span> <span class="nf">ccfab</span><span class="p">(</span><span class="n">ccbx</span><span class="p">);</span>
<span class="n">FArrayBox</span> <span class="nf">ndfab</span><span class="p">(</span><span class="n">ndbx</span><span class="p">);</span>
<span class="n">ccfab</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">ndfab</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ccfab</span><span class="p">);</span>   <span class="c1">// runtime error due to type mismatch</span>
</pre></div>
</div>
<p>Because it typically contains a lot of data, BaseFab’s copy
constructor and copy assignment operator are disabled for performance
reason. However, it does provide a move constructor. In addition, it
also provides a constructor for making an alias of an existing
object. Here is an example using FArrayBox.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">FArrayBox</span> <span class="nf">orig_fab</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 4-component FArrayBox</span>
<span class="c1">// Make a 2-component FArrayBox that is an alias of orig_fab</span>
<span class="c1">// starting from component 1.</span>
<span class="n">FArrayBox</span> <span class="nf">alias_fab</span><span class="p">(</span><span class="n">orig_fab</span><span class="p">,</span> <span class="n">amrex</span><span class="o">::</span><span class="n">make_alias</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>In the example, the alias <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> has only two components even
though the original one has four components. The alias has a sliced
component view of the original <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code>. This is possible
because of the array ordering. It is however not possible to slice in
the real space (i.e., the first <code class="docutils literal"><span class="pre">AMREX_SPACEDIM</span></code> dimensions).
Note that no new memory is allocated in constructing the alias and the
alias contains a non-owning pointer. It should be emphasized that the
alias will contain a dangling pointer after the original
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> reaches its end of life.</p>
</div>
<div class="section" id="fabarray-multifab-and-imultifab">
<span id="sec-basics-multifab"></span><h1>FabArray, MultiFab and iMultiFab<a class="headerlink" href="#fabarray-multifab-and-imultifab" title="Permalink to this headline">¶</a></h1>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArray</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">FAB</span></span><span class="operator"><span class="pre">&gt;</span></span></code> is a class template in AMReX_FabArray.H for
a collection of FABs on the same AMR level associated with a
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> (see the section on&nbsp;<a class="reference internal" href="#sec-basics-ba"><span class="std std-ref">BoxArray</span></a>). The template parameter
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FAB</span></span></code> is usually <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">&gt;</span></span></code> or its derived classes (e.g.,
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code>). However, it can also be used to hold other data
structures. To construct a FabArray, a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> must be
provided because it is intended to hold <em>grid</em> data defined on
a union of rectangular regions embedded in a uniform index space. For
example, an FabArray object can be used to hold data for one
level as in <a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 2</span></a>.</p>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArray</span></span></code> is a parallel data structure that the data (i.e.,
FAB) are distributed among parallel processes. On each process,
the FabArray contains only the FAB objects owned by this
process, and the process operates only on its local data. For
operations that require data owned by other processes, remote
communications are involved. Thus, the construction of a
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArray</span></span></code> requires a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code>
(see the section on&nbsp;<a class="reference internal" href="#sec-basics-dm"><span class="std std-ref">DistributionMapping</span></a>) that specifies which process owns which
Box. For level 2 (<em>red</em>) in in <a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 2</span></a>,
there are two Boxes. Suppose
there are two parallel processes, and we use a
DistributionMapping that assigns one Box to each process.
For <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArray</span></span></code> on each process, it is built on a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> with
2 Boxes, but contains only one FAB.</p>
<p>In AMReX, there are some specialized classes derived from
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArray</span></span></code>. The <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">iMultiFab</span></span></code> class in AMReX_iMultiFab.H is
derived from <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArray</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">IArrayBox</span></span><span class="operator"><span class="pre">&gt;</span></span></code>. The most commonly used
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArray</span></span></code> kind class is <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> in AMReX_MultiFab.H
derived from <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArray</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">FArrayBox</span></span><span class="operator"><span class="pre">&gt;</span></span></code>. In the rest of this section,
we use <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> as example. However, these concepts are equally
applicable to other types of FabArrays. There are many ways to
define a MultiFab. For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// ba is BoxArray</span>
<span class="c1">// dm is DistributionMapping</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">MultiFab</span> <span class="nf">mf</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we define a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> with 4 components and 1 ghost cell. A
MultiFab contains a number of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBoxes</span></span></code>
(see the section on&nbsp;<a class="reference internal" href="#sec-basics-fab"><span class="std std-ref">BaseFab, FArrayBox and IArrayBox</span></a>) defined on Boxes grown by the
number of ghost cells (1 in this example). That is the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> in
the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> is not exactly the same as in the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>.
If the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> has a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span><span class="punctuation"><span class="pre">{(</span></span><span class="literal number integer"><span class="pre">7</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">7</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">7</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">)}</span></span></code>, the one
used for constructing <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> will be <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span><span class="punctuation"><span class="pre">{(</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">)</span></span>
<span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">)}</span></span></code> in this example. For cells in <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code>, we
call those in the original <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> <strong>valid cells</strong> and the grown part
<strong>ghost cells</strong>. Note that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> itself does not have the
concept of ghost cells.
Ghost cells are a key concept of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code>,however,
that allows for local operations on ghost cell data
originated from remote processes. We will discuss how to fill ghost
cells with data from valid cells later in this section.
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> also has a default constructor. One can define an empty
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> first and then call the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">define</span></span></code> function as
follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">MultiFab</span> <span class="n">mf</span><span class="p">;</span>
<span class="c1">// ba is BoxArray</span>
<span class="c1">// dm is DistributionMapping</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mf</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
</pre></div>
</div>
<p>Given an existing <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code>, one can also make an alias
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// orig_mf is an existing MultiFab</span>
<span class="kt">int</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num_comps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">MultiFab</span> <span class="nf">alias_mf</span><span class="p">(</span><span class="n">orig_mf</span><span class="p">,</span> <span class="n">amrex</span><span class="o">::</span><span class="n">make_alias</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the first integer parameter is the starting component in the
original <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> that will become component 0 in the alias
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> and the second integer parameter is the number of
components in the alias. It’s a runtime error if the sum of the two
integer parameters is greater than the number of the components in the
original MultiFab. Note that the alias MultiFab has
exactly the same number of ghost cells as the original MultiFab.</p>
<p>We often need to build new MultiFabs that have the same
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code> as a given MultiFab.
Below is an example of how to achieve this.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// mf0 is an already defined MultiFab</span>
<span class="k">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">ba</span> <span class="o">=</span> <span class="n">mf0</span><span class="p">.</span><span class="n">boxArray</span><span class="p">();</span>
<span class="k">const</span> <span class="n">DistributionMapping</span><span class="o">&amp;</span> <span class="n">dm</span> <span class="o">=</span> <span class="n">mf0</span><span class="p">.</span><span class="n">DistributionMap</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="n">mf0</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="n">mf0</span><span class="p">.</span><span class="n">nGrow</span><span class="p">();</span>
<span class="n">MultiFab</span> <span class="nf">mf1</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="n">dm</span><span class="p">,</span><span class="n">ncomp</span><span class="p">,</span><span class="n">ngrow</span><span class="p">);</span>  <span class="c1">// new MF with the same ncomp and ngrow</span>
<span class="n">MultiFab</span> <span class="nf">mf2</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="n">dm</span><span class="p">,</span><span class="n">ncomp</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">// new MF with no ghost cells</span>
<span class="c1">// new MF with 1 component and 2 ghost cells</span>
<span class="n">MultiFab</span> <span class="nf">mf3</span><span class="p">(</span><span class="n">mf0</span><span class="p">.</span><span class="n">boxArray</span><span class="p">(),</span> <span class="n">mf0</span><span class="p">.</span><span class="n">DistributionMap</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>As we have repeatedly mentioned in this chapter that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> and
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> have various index types. Thus, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> also
has an index type that is obtained from the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> used for
defining the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code>. It should be noted again that index type
is a very important concept in AMReX. Let’s consider an example of a
finite-volume code, in which the state is defined as cell averaged
variables and the fluxes are defined as face averaged variables.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// ba is cell-centered BoxArray</span>
<span class="c1">// dm is DistributionMapping</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// Suppose the system has 3 components</span>
<span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// no ghost cells</span>
<span class="n">MultiFab</span> <span class="nf">state</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="nf">xflux</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="nf">yflux</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="nf">zflux</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Here all <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> use the same <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code>, but
their <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArrays</span></span></code> have different index types. The state is cell-based,
whereas the fluxes are on the faces. Suppose the cell based
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> contains a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span><span class="punctuation"><span class="pre">{(</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">),</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">31</span></span><span class="punctuation"><span class="pre">)}</span></span></code>. The
state on that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> is conceptually a Fortran Array with the
dimension of <code class="code fortran docutils literal"><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">31</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">2</span></span><span class="punctuation"><span class="pre">)</span></span></code>. The fluxes are arrays with
slightly different indices. For example, the <span class="math">\(x\)</span>-direction flux for
that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> has the dimension of <code class="code fortran docutils literal"><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">31</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">2</span></span><span class="punctuation"><span class="pre">)</span></span></code>. Note
there is an extra element in <span class="math">\(x\)</span>-direction.</p>
<p>The <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> class provides many functions performing common
arithmetic operations on a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> or between <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFabs</span></span></code>
built with the <em>same</em> <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMap</span></span></code>.
For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="n">dmin</span> <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>   <span class="c1">// Minimum value in component 3 of MultiFab mf</span>
                         <span class="c1">// no ghost cells included</span>
<span class="n">Real</span> <span class="n">dmax</span> <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Maximum value in component 3 of MultiFab mf</span>
                         <span class="c1">// including 1 ghost cell</span>
<span class="n">mf</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>          <span class="c1">// Set all values to zero including ghost cells</span>

<span class="n">MultiFab</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="n">mfdst</span><span class="p">,</span> <span class="n">mfsrc</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span>  <span class="c1">// Add mfsrc to mfdst</span>
<span class="n">MultiFab</span><span class="o">::</span><span class="n">Copy</span><span class="p">(</span><span class="n">mfdst</span><span class="p">,</span> <span class="n">mfsrc</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span> <span class="c1">// Copy from mfsrc to mfdst</span>
<span class="c1">// MultiFab mfdst: destination</span>
<span class="c1">// MultiFab mfsrc: source</span>
<span class="c1">// int      sc   : starting component index in mfsrc for this operation</span>
<span class="c1">// int      dc   : starting component index in mfdst for this operation</span>
<span class="c1">// int      sc   : number of components for this operation</span>
<span class="c1">// int      ng   : number of ghost cells involved in this operation</span>
<span class="c1">//                 mfdst and mfsrc may have more ghost cells</span>
</pre></div>
</div>
<p>We refer the reader to <code class="docutils literal"><span class="pre">amrex/Src/Base/AMReX_MultiFab.H</span></code> and
<code class="docutils literal"><span class="pre">amrex/Src/Base/AMReX_FabArray.H</span></code> for more details. It should be noted
again it is a runtime error if the two <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFabs</span></span></code> passed to functions
like <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Copy</span></span></code> are not built with the <em>same</em>
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> (including index type) and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code>.</p>
<p>It is usually the case that the Boxes in the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> used
for building a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> are non-intersecting except that they
can be overlapping due to nodal index type. However, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code>
can have ghost cells, and in that case FArrayBoxes are defined
on Boxes larger than the Boxes in the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>.
Parallel communication is then needed to fill the ghost cells with
valid cell data from other FArrayBoxes possibly on other
parallel processes. The function for performing this type of
communication is <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FillBoundary</span></span></code>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">MultiFab</span> <span class="nf">mf</span><span class="p">(...</span><span class="n">parameters</span> <span class="n">omitted</span><span class="p">...);</span>
<span class="n">Geometry</span> <span class="nf">geom</span><span class="p">(...</span><span class="n">parameters</span> <span class="n">omitted</span><span class="p">...);</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">();</span>                    <span class="c1">// Fill ghost cells for all components</span>
                                      <span class="c1">// Periodic boundaries are not filled.</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">periodicity</span><span class="p">());</span>  <span class="c1">// Fill ghost cells for all components</span>
                                      <span class="c1">// Periodic boundaries are filled.</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>        <span class="c1">// Fill 3 components starting from component 2</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">periodicity</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FillBoundary</span></span></code> does not modify any valid cells. Also
note that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> itself does not have the concept of
periodic boundary, but <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Geometry</span></span></code> has, and we can provide that
information so that periodic boundaries can be filled as well. You
might have noticed that a ghost cell could overlap with multiple valid
cells from different FArrayBoxes in the case of nodal index
type. In that case, it is unspecified that which valid cell’s value
is used to fill the ghost cell. It ought to be the case the values in
those overlapping valid cells are the same up to roundoff errors.</p>
<p>Another type of parallel communication is copying data from one
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> to another <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> with a different <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>
or the same <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code> with a different
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code>. The data copy is performed on the regions of
intersection. The most generic interface for this is</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">mfdst</span><span class="p">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">compsrc</span><span class="p">,</span> <span class="n">compdst</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngsrc</span><span class="p">,</span> <span class="n">ngdst</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfdst</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfsrc</span></span></code> are destination and source
MultiFabs, respectively. Parameters <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">compsrc</span></span></code>, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">compdst</span></span></code>, and
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ncomp</span></span></code> are integers specifying the range of components. The copy is
performed on <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ncomp</span></span></code> components starting from component <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">compsrc</span></span></code> of
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfsrc</span></span></code> and component <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">compdst</span></span></code> of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfdst</span></span></code>. Parameters
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ngsrc</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ngdst</span></span></code> specify the number of ghost cells involved for
the source and destination, respectively. Parameter <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">period</span></span></code> is
optional, and by default no periodic copy is performed. Like
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FillBoundary</span></span></code>, one can use <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Geometry</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">periodicity</span></span><span class="punctuation"><span class="pre">()</span></span></code> to provide
the periodicity information. The last parameter is also optional and
is set to <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArrayBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">COPY</span></span></code> by default. One could also use
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FabArrayBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ADD</span></span></code>. This determines whether the function copies
or adds data from the source to the destination. Same as
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FillBoundary</span></span></code>, if a destination cell has multiple cells as source,
it is unspecified that which source cell is used. This function has
two variants, in which the periodicity and operation type are also
optional.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">mfdst</span><span class="p">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>  <span class="c1">// mfdst and mfsrc must have the same</span>
                                        <span class="c1">// number of components</span>
<span class="n">mfdst</span><span class="p">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">compsrc</span><span class="p">,</span> <span class="n">compdst</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the number of ghost cells involved is zero, and the copy is
performed on all components if unspecified (assuming the two
MultiFabs have the same number of components). Similar to
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FillBoundary</span></span></code>, a destination cell may have multiple sources and
which source is used is unspecified.</p>
</div>
<div class="section" id="mfiter-and-tiling">
<span id="sec-basics-mfiter"></span><h1>MFIter and Tiling<a class="headerlink" href="#mfiter-and-tiling" title="Permalink to this headline">¶</a></h1>
<p>In this section, we will first show how <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> works without
tiling. Then we will introduce the concept of logical tiling.
Finally we will show how logical tiling can be launched via
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code>.</p>
<div class="section" id="mfiter-without-tiling">
<span id="sec-basics-mfiter-notiling"></span><h2>MFIter without Tiling<a class="headerlink" href="#mfiter-without-tiling" title="Permalink to this headline">¶</a></h2>
<p>In the section on&nbsp;<a class="reference internal" href="#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a>, we have shown some of the
arithmetic functionalities of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code>, such as adding two
MultiFabs together. In this section, we will show how you can
operate on the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> data with your own functions. AMReX
provides an iterator, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> for looping over the
FArrayBoxes in MultiFabs. For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over grids</span>
<span class="p">{</span>
    <span class="c1">// This is the valid Box of the current FArrayBox.</span>
    <span class="c1">// By &quot;valid&quot;, we mean the original ungrown Box in BoxArray.</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>

    <span class="c1">// A reference to the current FArrayBox in this loop iteration.</span>
    <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

    <span class="c1">// Pointer to the floating point data of this FArrayBox.</span>
    <span class="n">Real</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">();</span>

    <span class="c1">// This is the Box on which the FArrayBox is defined.</span>
    <span class="c1">// Note that &quot;abox&quot; includes ghost cells (if there are any),</span>
    <span class="c1">// and is thus larger than or equal to &quot;box&quot;.</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">abox</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>

    <span class="c1">// We can now pass the information to a function that does</span>
    <span class="c1">// work on the region (specified by box) of the data pointed to</span>
    <span class="c1">// by Real* a.  The data should be viewed as a multidimensional</span>
    <span class="c1">// with bounds specified by abox.</span>
    <span class="c1">// Function f1 has the signature of</span>
    <span class="c1">// void f1(const int*, const int*, Real*, const int*, const int*);</span>
    <span class="n">f1</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">abox</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">abox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">f1</span></span></code> is usually a Fortran subroutine with ISO C
binding interface like below,</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f1</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">alo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ahi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">a</span><span class="p">(</span><span class="n">alo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">ahi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">alo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">ahi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">alo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">ahi</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span>
  <span class="k">do     </span><span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">do   </span><span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
      <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="p">...</span>
      <span class="k">end do</span>
<span class="k">    end do</span>
<span class="k">  end do</span>
<span class="k">end subroutine </span><span class="n">f1</span>
</pre></div>
</div>
<p>Here <code class="code fortran docutils literal"><span class="name"><span class="pre">amrex_fort_module</span></span></code> is a Fortran module in AMReX&nbsp;and
<code class="code fortran docutils literal"><span class="name"><span class="pre">amrex_real</span></span></code> is a Fortran kind parameter that matches
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Real</span></span></code> in C++. In this example, we assumed the spatial
dimension is 3. In 2D, the function interface is different. In the
section&nbsp;on <a class="reference internal" href="#sec-basics-fortran"><span class="std std-ref">Calling Fortran or C</span></a>, we will present a dimension-agnostic
approach using macros provided by AMReX.</p>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> only loops over grids owned by this process. For
example, suppose there are 5 Boxes in total and processes 0 and
1 own 2 and 3 Boxes, respectively. That is the MultiFab
on process 0 has 2 FArrayBoxes, whereas there are 3
FArrayBoxes on process 1. Thus the numbers of iterations of
MFIter are 2 and 3 on processes 0 and 1, respectively.</p>
<p>In the example above, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> is assumed to have a single
component. If it has multiple components, we can call <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">nc</span></span> <span class="operator"><span class="pre">=</span></span>
<span class="name"><span class="pre">mf</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">nComp</span></span><span class="punctuation"><span class="pre">()</span></span></code> to get the number of components and pass <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">nc</span></span></code> to the
kernel function.</p>
<p>There is only one <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> in the example above. Below is an
example of working with multiple MultiFabs. Note that these two
MultiFabs are not necessarily built on the same <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>.
But they must have the same <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code>, and their
BoxArrays are typically related (e.g., they are different due to
index types).</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// U and F are MultiFabs</span>
<span class="kt">int</span> <span class="n">ncU</span> <span class="o">=</span> <span class="n">U</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span>   <span class="c1">// number of components</span>
<span class="kt">int</span> <span class="n">ncF</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over grids</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">ufab</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="n">FArrayBox</span><span class="o">&amp;</span>       <span class="n">ffab</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

    <span class="n">Real</span><span class="o">*</span> <span class="n">up</span> <span class="o">=</span> <span class="n">ufab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">();</span>
    <span class="n">Real</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">ufab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">ubox</span> <span class="o">=</span> <span class="n">ufab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">fbox</span> <span class="o">=</span> <span class="n">ffab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>

    <span class="c1">// Function f2 has the signature of</span>
    <span class="c1">// void f2(const int*, const int*,</span>
    <span class="c1">//         const Real*, const int*, const int*, const int*</span>
    <span class="c1">//               Real*, const int*, const int*, const int*);</span>
    <span class="c1">// This will compute f using u as inputs.</span>
    <span class="n">f2</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span>
       <span class="n">up</span><span class="p">,</span> <span class="n">ubox</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">ubox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ncU</span><span class="p">,</span>
       <span class="n">fp</span><span class="p">,</span> <span class="n">fbox</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">fbox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ncF</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here again function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">f2</span></span></code> is usually a Fortran subroutine with ISO
C binding interface like below,</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f2</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">flo</span><span class="p">,</span> <span class="n">fhi</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span><span class="p">,</span><span class="n">flo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">fhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nf</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span>   <span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span><span class="p">)</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">f</span><span class="p">(</span><span class="n">flo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">fhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">flo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">fhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">flo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">fhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nf</span><span class="p">)</span>
  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span>
  <span class="k">do </span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nf</span>
    <span class="k">do     </span><span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
      <span class="k">do   </span><span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="p">...</span> <span class="n">u</span><span class="p">(...)</span> <span class="p">...</span>
        <span class="k">end do</span>
<span class="k">      end do</span>
<span class="k">    end do</span>
<span class="k">  end do</span>
<span class="k">end subroutine </span><span class="n">f2</span>
</pre></div>
</div>
</div>
<div class="section" id="mfiter-with-tiling">
<span id="sec-basics-mfiter-tiling"></span><h2>MFIter with Tiling<a class="headerlink" href="#mfiter-with-tiling" title="Permalink to this headline">¶</a></h2>
<p>Tiling, also known as cache blocking, is a well known loop
transformation technique for improving data locality. This is often
done by transforming the loops into tiling loops that iterate over
tiles and element loops that iterate over the data elements within a
tile. For example, the original loops might look like</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span>
  <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span>
    <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span>
      <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="p">&amp;</span>
                <span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">6.0d0</span><span class="o">*</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
    <span class="k">end do</span>
<span class="k">  end do</span>
<span class="k">end do</span>
</pre></div>
</div>
<p>And the manually tiled loops might look like</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="n">jblocksize</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">kblocksize</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">jblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">jmax</span><span class="o">-</span><span class="n">jmin</span><span class="o">+</span><span class="n">jblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">jblocksize</span>
<span class="n">kblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">kmax</span><span class="o">-</span><span class="n">kmin</span><span class="o">+</span><span class="n">kblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">kblocksize</span>
<span class="k">do </span><span class="n">kb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kblocks</span><span class="o">-</span><span class="mi">1</span>
  <span class="k">do </span><span class="n">jb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jblocks</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="n">kb</span><span class="o">*</span><span class="n">kblocksize</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">kb</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">kblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">kmax</span><span class="p">)</span>
      <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">jb</span><span class="o">*</span><span class="n">jblocksize</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">jb</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">jblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">jmax</span><span class="p">)</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span>
          <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="p">&amp;</span>
                    <span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">6.0d0</span><span class="o">*</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">end do</span>
<span class="k">      end do</span>
<span class="k">    end do</span>
<span class="k">  end do</span>
<span class="k">end do</span>
</pre></div>
</div>
<p>As we can see, to manually tile individual loops is very
labor-intensive and error-prone for large applications. AMReX&nbsp;has
incorporated the tiling construct into <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> so that the
application codes can get the benefit of tiling easily. An
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> loop with tiling is almost the same as the non-tiling
version. The first example in (see the previous section on
<a class="reference internal" href="#sec-basics-mfiter-notiling"><span class="std std-ref">MFIter without Tiling</span></a>) requires only two minor
changes:</p>
<blockquote>
<div><ol class="arabic simple">
<li>passing <code class="code cpp c++ docutils literal"><span class="name builtin"><span class="pre">true</span></span></code> when defining <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> to indicate tiling;</li>
<li>calling <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">tilebox</span></span></code> instead of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">validbox</span></span></code> to obtain the work region
for the loop iteration.</li>
</ol>
</div></blockquote>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">//               * true *  turns on tiling</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over tiles</span>
<span class="p">{</span>
    <span class="c1">//                   tilebox() instead of validbox()</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>

    <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="n">Real</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">abox</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>

    <span class="n">f1</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">abox</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">abox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second example in the previous section on&nbsp;<a class="reference internal" href="#sec-basics-mfiter-notiling"><span class="std std-ref">MFIter without Tiling</span></a>
also requires only two minor changes.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">//              * true *  turns on tiling</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over tiles</span>
<span class="p">{</span>
    <span class="c1">//                   tilebox() instead of validbox()</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">ufab</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="n">FArrayBox</span><span class="o">&amp;</span>       <span class="n">ffab</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

    <span class="n">Real</span><span class="o">*</span> <span class="n">up</span> <span class="o">=</span> <span class="n">ufab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">();</span>
    <span class="n">Real</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">ufab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">ubox</span> <span class="o">=</span> <span class="n">ufab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">fbox</span> <span class="o">=</span> <span class="n">ffab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>

    <span class="n">f2</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span>
       <span class="n">up</span><span class="p">,</span> <span class="n">ubox</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">ubox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ncU</span><span class="p">,</span>
       <span class="n">fp</span><span class="p">,</span> <span class="n">fbox</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">fbox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ncF</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The kernels functions like <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">f1</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">f2</span></span></code> in the two examples
here usually require very little changes.</p>
<span id="fig-basics-cc-comparison"></span><table border="1" class="docutils align-center" id="id4">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">Comparison of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> with (right) and without (left) tiling.</span><a class="headerlink" href="#id4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="_images/cc_validbox.png"><img alt="a" src="_images/cc_validbox.png" style="width: 90%;" /></a></td>
<td><a class="reference internal" href="_images/cc_tilebox.png"><img alt="b" src="_images/cc_tilebox.png" style="width: 90%;" /></a></td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">Example of cell-centered valid boxes.</div>
<div class="line">There are two valid boxes in this example.</div>
<div class="line">Each has <span class="math">\(8^2\)</span> cells.</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Example of cell-centered tile boxes. Each grid is</div>
<div class="line"><em>logically</em> broken into 4 tiles, and each tile as</div>
<div class="line"><span class="math">\(4^2\)</span> cells. There are 8 tiles in total.</div>
</div>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#fig-basics-cc-comparison"><span class="std std-numref">Table 3</span></a>
shows an example of the difference between <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">validbox</span></span></code> and
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">tilebox</span></span></code>. In this example, there are two grids of cell-centered
index type. The function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">validbox</span></span></code> always returns a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> for the
valid region of an <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> no matter whether or not tiling is
enabled, whereas the function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">tilebox</span></span></code> returns a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> for a
tile. (Note that when tiling is disabled, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">tilebox</span></span></code> returns the
same <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> as <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">validbox</span></span></code>.) The number of loop iteration is 2
in the non-tiling version, whereas in the tiling version the kernel
function is called 8 times.</p>
<p>The tile size can be explicitly set when defining <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// No tiling in x-direction. Tile size is 16 for y and 32 for z.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">IntVect</span><span class="p">(</span><span class="mi">1024000</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">));</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="p">{...}</span>
</pre></div>
</div>
<p>An <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span></code> is used to specify the tile size for every dimension.
A tile size larger than the grid size simply means tiling is disable
in that direction. AMReX&nbsp;has a default tile size <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">IntVect</span></span><span class="punctuation"><span class="pre">{</span></span><span class="literal number integer"><span class="pre">1024000</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">}</span></span></code>
in 3D and no tiling in 2D. This is used when tile size is not explicitly set
but the tiling flag is on. One can change the default size using <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code>
parameter <code class="docutils literal"><span class="pre">fabarray.mfiter_tile_size.</span></code></p>
<span id="fig-basics-ec-comparison"></span><table border="1" class="docutils align-center" id="id5">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">Comparison of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> with (right) and without (left) tiling, for face-centered nodal indexing.</span><a class="headerlink" href="#id5" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="_images/ec_validbox.png"><img alt="c" src="_images/ec_validbox.png" style="width: 90%;" /></a></td>
<td><a class="reference internal" href="_images/ec_tilebox.png"><img alt="d" src="_images/ec_tilebox.png" style="width: 90%;" /></a></td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">Example of face valid boxes. There are two valid</div>
<div class="line">boxes in this example. Each has <span class="math">\(9\times 8\)</span></div>
<div class="line">points. Note that points in one <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> may</div>
<div class="line">overlap with points in the other <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code>.</div>
<div class="line">However, the memory locations for storing</div>
<div class="line">floating point data of those points do not</div>
<div class="line">overlap, because they belong to seperate</div>
<div class="line">FArrayBoxes.</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Example of face tile boxes. Each grid is</div>
<div class="line"><em>logically</em> broken into 4 tiles as indicated by</div>
<div class="line">the symbols. There are 8 tiles in total. Some</div>
<div class="line">tiles have <span class="math">\(5\times 4\)</span> points, whereas</div>
<div class="line">others have <span class="math">\(4 \times 4\)</span> points. Points from</div>
<div class="line">different Boxes may overlap, but points from</div>
<div class="line">different tiles of the same Box do not.</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Usually <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> is used for accessing multiple MultiFabs
like the second example, in which two MultiFabs, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">U</span></span></code> and
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">F</span></span></code>, use <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> via <code class="code cpp c++ docutils literal"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code>. These different
MultiFabs may have different BoxArrays. For example, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">U</span></span></code>
might be cell-centered, whereas <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">F</span></span></code> might be nodal in
<span class="math">\(x\)</span>-direction and cell in other directions. The
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">validbox</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">tilebox</span></span></code> functions return Boxes of
the same type as the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> used in defining the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code>
(<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">F</span></span></code> in this example).
<a class="reference internal" href="#fig-basics-ec-comparison"><span class="std std-numref">Table 4</span></a>
illustrates an example of non-cell-centered valid
and tile boxes. Besides <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">validbox</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">tilebox</span></span></code>,
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> has a number of functions returning various Boxes.
Examples include,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">fabbox</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>       <span class="c1">// Return the Box of the FArrayBox</span>

<span class="c1">// Return grown tile box.  By default it grows by the number of</span>
<span class="c1">// ghost cells of the MultiFab used for defining the MFIter.</span>
<span class="n">Box</span> <span class="nf">growntilebox</span><span class="p">(</span><span class="kt">int</span> <span class="n">ng</span><span class="o">=-</span><span class="mi">1000000</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// Return tilebox with provided nodal flag as if the MFIter</span>
<span class="c1">// is constructed with MultiFab of such flag.</span>
<span class="n">Box</span> <span class="nf">tilebox</span><span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">nodal_flag</span><span class="p">);</span>
</pre></div>
</div>
<p>It should be noted that the function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">growntilebox</span></span></code> does not grow the
tile Box like a normal <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code>. Growing a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> normally
means the Box is extended in every face of every dimension.
However, the function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">growntilebox</span></span></code> only extends the tile Box
in such a way that tiles from the same grid do not overlap. This is
the basic design principle of these various tiling functions. Tiling
is a way of domain decomposition for work sharing. Overlapping tiles
is undesirable because work would be wasted and for multi-threaded
codes race conditions could occur.</p>
<span id="fig-basics-growbox-comparison"></span><table border="1" class="docutils align-center" id="id6">
<caption><span class="caption-number">Table 5 </span><span class="caption-text">Comparing growing cell-type and face-type tile boxes.</span><a class="headerlink" href="#id6" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="_images/cc_growbox.png"><img alt="e" src="_images/cc_growbox.png" style="width: 90%;" /></a></td>
<td><a class="reference internal" href="_images/ec_growbox.png"><img alt="f" src="_images/ec_growbox.png" style="width: 90%;" /></a></td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">Example of cell-centered grown tile boxes. As</div>
<div class="line">indicated by symbols, there are 8 tiles and four</div>
<div class="line">in each grid in this example. Tiles from the same</div>
<div class="line">grid do not overlap. But tiles from different</div>
<div class="line">grids may overlap.</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Example of face type grown tile boxes. As</div>
<div class="line">indicated by symbols, there are 8 tiles and four</div>
<div class="line">in each grid in this example. Tiles from the same</div>
<div class="line">grid do not overlap even though they have face</div>
<div class="line">index type.</div>
</div>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#fig-basics-growbox-comparison"><span class="std std-numref">Table 5</span></a>
illustrates an example of <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">growntilebox</span></span></code>. These functions in <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code>
return <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> by value. There are two ways of using these
functions.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>  <span class="c1">// const&amp; to temporary object is legal</span>

<span class="c1">// Make a copy if Box needs to be modified later.</span>
<span class="c1">// Compilers can optimize away the temporary object.</span>
<span class="n">Box</span> <span class="n">bx2</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>
<span class="n">bx2</span><span class="p">.</span><span class="n">surroundingNodes</span><span class="p">();</span>
</pre></div>
</div>
<p>But <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span><span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">bx</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">mfi</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">validbox</span></span><span class="punctuation"><span class="pre">()</span></span></code> is not legal and will not compile.</p>
</div>
</div>
<div class="section" id="calling-fortran-or-c">
<span id="sec-basics-fortran"></span><h1>Calling Fortran or C<a class="headerlink" href="#calling-fortran-or-c" title="Permalink to this headline">¶</a></h1>
<p>In the section&nbsp;on <a class="reference internal" href="#sec-basics-mfiter"><span class="std std-ref">MFIter and Tiling</span></a>, we have shown that a typical
pattern for working with MultiFabs is to use <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIter</span></span></code> to
iterate over the data. In each iteration, a kernel function is called
to work on the data and the work region is specified by a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code>.
When tiling is used, the work region is a tile. The tiling is logical
in the sense that there is no data layout transformation. The kernel
function still gets the whole arrays in <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBoxes</span></span></code>, even though
it is supposed to work on a tile region of the arrays. To C++, these
kernel functions are C functions, whose function signatures are
typically declared in a header file named <code class="docutils literal"><span class="pre">*_f.H</span></code> or
<code class="docutils literal"><span class="pre">*_F.H</span></code>. We recommend the users to follow this convention.
Examples of these function declarations are as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;AMReX_BLFort.H&gt;</span><span class="cp"></span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="p">{</span>
<span class="cp">#endif</span>
    <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span>
            <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>One can write the functions in C and should include the header
containing the function declarations in the C source code to ensure
type safety. However, we typically write these kernel functions in
Fortran because of the native multi-dimensional array support by
Fortran. As we have seen in the section&nbsp;on <a class="reference internal" href="#sec-basics-mfiter"><span class="std std-ref">MFIter and Tiling</span></a>, these
Fortran functions take C pointers and view them as multi-dimensional
arrays of the shape specified by the additional integer arguments.
Note that Fortran takes arguments by reference unless the <code class="code fortran docutils literal"><span class="keyword"><span class="pre">value</span></span></code>
keyword is used. So an integer argument on the Fortran side matches
an integer pointer on the C++&nbsp;side. Thanks to Fortran 2003,
function name mangling is easily achieved by declaring the Fortran
function as <code class="code fortran docutils literal"><span class="keyword"><span class="pre">bind</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">c</span></span><span class="punctuation"><span class="pre">)</span></span></code>.</p>
<p>AMReX&nbsp;provides many macros for passing an FArrayBox’s data
into Fortran/C. For example</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>
    <span class="n">f</span><span class="p">(</span><span class="n">BL_TO_FORTRAN_BOX</span><span class="p">(</span><span class="n">box</span><span class="p">),</span>
      <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">]));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BL_TO_FORTRAN_BOX</span></span></code> takes a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Box</span></span></code> and provides two
<code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code> s specifying the lower and upper bounds of the Box.
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BL_TO_FORTRAN_ANYD</span></span></code> takes an <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> returned by
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mf</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">mfi</span></span><span class="punctuation"><span class="pre">]</span></span></code> and the preprocessor turns it into <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Real</span></span> <span class="operator"><span class="pre">*</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code>,
where <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Real</span></span> <span class="operator"><span class="pre">*</span></span></code> is the data pointer that matches real array argument
in Fortran, the first <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code> (which matches an integer argument in
Fortran) specifies the lower bounds, and the second <code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code> the
upper bounds of the spatial dimensions of the array. Similar to what
we have seen in the section on&nbsp;<a class="reference internal" href="#sec-basics-mfiter"><span class="std std-ref">MFIter and Tiling</span></a>, a matching Fortran
function is shown below,</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="k">end subroutine </span><span class="n">f</span>
</pre></div>
</div>
<p>Here, the size of the integer arrays is 3, the maximal number of
spatial dimensions. If the actual spatial dimension is less than 3,
the values in the degenerate dimensions are set to zero. So the
Fortran function interface does not have to change according to the
spatial dimensionality, and the bound of the third dimension of the
data array simply becomes <code class="code fortran docutils literal"><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">0</span></span></code>. With the data passed by
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BL_TO_FORTRAN_BOX</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BL_FORTRAN_ANYD</span></span></code>, this version of
Fortran function interface works for any spatial dimensions. If one
wants to write a special version just for 2D and would like to use 2D
arrays, one can use</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f2d</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="k">end subroutine </span><span class="n">f2d</span>
</pre></div>
</div>
<p>Note that this does not require any changes in the C++&nbsp;part, because
when C++&nbsp;passes an integer pointer pointing to an array of three
integers Fortran can treat it as a 2-element integer array.</p>
<p>Another commonly used macro is <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BL_TO_FORTRAN</span></span></code>. This macro
takes an <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FArrayBox</span></span></code> and provides a real pointer for the floating
point data array and a number of integer scalars for the bounds.
However, the number of the integers depends on the dimensionality.
More specifically, there are 6 and 4 integers for 2D and 3D,
respectively. The first half of the integers are the lower bounds for
each spatial dimension and the second half the upper bounds. For
example,</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo1</span><span class="p">:</span><span class="n">uhi1</span><span class="p">,</span><span class="n">ulo2</span><span class="p">:</span><span class="n">uhi2</span><span class="p">)</span>
<span class="k">end subroutine </span><span class="n">f2d</span>

<span class="k">subroutine </span><span class="n">f3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">ulo3</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">,</span> <span class="n">uhi3</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">ulo3</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">,</span> <span class="n">uhi3</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo1</span><span class="p">:</span><span class="n">uhi1</span><span class="p">,</span><span class="n">ulo2</span><span class="p">:</span><span class="n">uhi2</span><span class="p">,</span><span class="n">ulo3</span><span class="p">:</span><span class="n">uhi3</span><span class="p">)</span>
<span class="k">end subroutine </span><span class="n">f3d</span>
</pre></div>
</div>
<p>Here for simplicity we have omitted passing the tile Box.</p>
<p>Usually <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFabs</span></span></code> have multiple components. Thus we often also
need to pass the number of component into Fortran functions. We can
obtain the number by calling the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">nComp</span></span><span class="punctuation"><span class="pre">()</span></span></code> function, and
pass it to Fortran as we have seen in the section&nbsp;on <a class="reference internal" href="#sec-basics-mfiter"><span class="std std-ref">MFIter and Tiling</span></a>.
We can also use the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BL_TO_FORTRAN_FAB</span></span></code> macro that is similar
to <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BL_TO_FORTRAN_ANYD</span></span></code> except that it provides an additional
<code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code> for the number of components. The Fortran function
matching <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BL_TO_FORTRAN_FAB</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">fab</span></span><span class="punctuation"><span class="pre">)</span></span></code> is then like below,</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">,</span><span class="n">nu</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span><span class="p">)</span>
<span class="k">end subroutine </span><span class="n">f</span>
</pre></div>
</div>
</div>
<div class="section" id="ghost-cells">
<h1>Ghost Cells<a class="headerlink" href="#ghost-cells" title="Permalink to this headline">¶</a></h1>
<p>AMReX&nbsp;uses <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> as the data container for floating point
data on multiple Boxes on a single AMR level. Each rectangular
Box has its own boundaries. A <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> can have ghost cells for
storing data outside its grid Box boundaries. This allows us to
perform stencil type of operations on regular arrays. There are three
basic types of boundaries:</p>
<blockquote>
<div><ol class="arabic simple">
<li>interior boundary</li>
<li>coarse/fine boundary</li>
<li>physical boundary.</li>
</ol>
</div></blockquote>
<p>Periodic boundary is not considered a basic type in the discussion here
because after periodic transformation it becomes either interior
boundary or coarse/fine boundary.</p>
<p>Interior boundary is the border among the grid Boxes themselves.
For example, in
<a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 2</span></a>,
the two blue grid Boxes on level 1 share an
interior boundary that is 10 cells long. For a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> with ghost
cells on level 1, we can use the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">FillBoundary</span></span></code> function
introduced in the section&nbsp;on <a class="reference internal" href="#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a> to fill ghost
cells at the interior boundary with valid cell data from other Boxes.</p>
<p>A coarse/fine boundary is the border between two AMR levels.
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">FillBoundary</span></span></code> does not fill these ghost cells. These ghost cells on
the fine level need to be interpolated from the coarse level data.
This is a subject that will be discussed in the section on
<a class="reference internal" href="AmrCore.html#sec-amrcore-fillpatch"><span class="std std-ref">FillPatchUtil and Interpolater</span></a>.</p>
<p>The third type of boundary is the physical boundary at the physical
domain. Note that both coarse and fine AMR levels could have grids
touching the physical boundary. It is up to the application codes to
properly fill the ghost cells at the physical boundary. However,
AMReX&nbsp;does provide support for some common operations.
See the chapter on <a class="reference internal" href="Boundary.html#chap-boundary"><span class="std std-ref">Boundary Conditions</span></a> for a discussion on domain
boundary conditions in general, including how to implement
physical (non-periodic) boundary conditions.</p>
</div>
<div class="section" id="i-o">
<h1>I/O<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h1>
<p>In this section, we will discuss parallel I/O capabilities for mesh
data in AMReX. The section&nbsp;on <a class="reference internal" href="Particle.html#sec-particles-io"><span class="std std-ref">Particle IO</span></a> will discuss I/O for
particle data.</p>
<div class="section" id="plotfile">
<h2>Plotfile<a class="headerlink" href="#plotfile" title="Permalink to this headline">¶</a></h2>
<p>AMReX&nbsp;has its own native plotfile format. Many visualization tools are
available for AMReX&nbsp;plotfiles (see the chapter on&nbsp;<a class="reference internal" href="Chapter11.html#chap-visualization"><span class="std std-ref">Visualization</span></a>).
AMReX&nbsp;provides the following two functions for writing a generic AMReX&nbsp;plotfile.
Many AMReX&nbsp;application codes may have their own plotfile routines that store
additional information such as compiler options, git hashes of the
source codes and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">ParmParse</span></span></code> runtime parameters.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">WriteSingleLevelPlotfile</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">plotfilename</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">MultiFab</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">varnames</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span><span class="n">geom</span><span class="p">,</span>
                               <span class="n">Real</span> <span class="n">time</span><span class="p">,</span>
                               <span class="kt">int</span> <span class="n">level_step</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">WriteMultiLevelPlotfile</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">plotfilename</span><span class="p">,</span>
                              <span class="kt">int</span> <span class="n">nlevels</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MultiFab</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">varnames</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">geom</span><span class="p">,</span>
                              <span class="n">Real</span> <span class="n">time</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">level_steps</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">IntVect</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ref_ratio</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">WriteSingleLevelPlotfile</span></span></code> is for single level runs and
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">WriteMultiLevelPlotfile</span></span></code> is for multiple levels. The name of the
plotfile is specified by the plotfilename argument. This is the
top level directory name for the plotfile. In AMReX&nbsp;convention, the
plotfile name consist of letters followed by numbers (e.g.,
plt00258). <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Concatenate</span></span></code> is a useful helper function for
making such strings.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">istep</span> <span class="o">=</span> <span class="mi">258</span><span class="p">;</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">);</span> <span class="c1">// plt00258</span>

<span class="c1">// By default there are 5 digits, but we can change it to say 4.</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname2</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// plt0258</span>

<span class="n">istep</span> <span class="o">=</span><span class="mi">1234567</span><span class="p">;</span>  <span class="c1">// Having more than 5 digits is OK.</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pfname3</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">Concatenate</span><span class="p">(</span><span class="s">&quot;plt&quot;</span><span class="p">,</span><span class="n">istep</span><span class="p">);</span> <span class="c1">// plt12344567</span>
</pre></div>
</div>
<p>The argument <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mf</span></span></code> above (<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> for single level and
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword"><span class="pre">const</span></span> <span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">*&gt;</span></span></code> for multi-level) is the data to be written
to the disk. Note that many visualization tools expect this to be
cell-centered data. So for nodal data, we need to convert them to
cell-centered data through some kind of averaging. Also note that if
you have data at each AMR level in several MultiFabs, you need
to build a new MultiFab at each level to hold all the data on
that level. This involves local data copy in memory and is not
expected to significantly increase the total wall time for writing
plotfiles. For the multi-level version, the function expects
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword"><span class="pre">const</span></span> <span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">*&gt;</span></span></code>, whereas the multi-level data are often
stored as <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">unique_ptr</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">&gt;&gt;</span></span></code>. AMReX&nbsp;has a
helper function for this and one can use it as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">WriteMultiLevelPlotfile</span><span class="p">(......,</span> <span class="n">amrex</span><span class="o">::</span><span class="n">GetVecOfConstPtrs</span><span class="p">(</span><span class="n">mf</span><span class="p">),</span> <span class="p">......);</span>
</pre></div>
</div>
<p>The argument <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">varnames</span></span></code> has the names for each component of the
MultiFab data. The size of the Vector should be equal to the
number of components. The argument <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">geom</span></span></code> is for passing
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Geometry</span></span></code> objects that contain the physical domain
information. The argument <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">time</span></span></code> is for the time associated with the
data. The argument <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">level_step</span></span></code> is for the current time step
associated with the data. For multi-level plotfiles, the argument
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">nlevels</span></span></code> is the total number of levels, and we also need to provide
the refinement ratio via an <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span></code> of size nlevels-1.</p>
<p>We note that AMReX&nbsp;does not overwrite old plotfiles if the new
plotfile has the same name. The old plotfiles will be renamed to
new directories named like plt00350.old.46576787980.</p>
</div>
<div class="section" id="checkpoint-file">
<h2>Checkpoint File<a class="headerlink" href="#checkpoint-file" title="Permalink to this headline">¶</a></h2>
<p>Checkpoint files are used for restarting simulations from where the
checkpoints are written. Each application code has its own set of
data needed for restart. AMReX&nbsp;provides I/O functions for basic
data structures like <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">BoxArray</span></span></code>. These
functions can be used to build codes for reading and writing
checkpoint files. Since each application code has its own
requirement, there is no standard AMReX&nbsp;checkpoint format.</p>
<p>Typically a checkpoint file is a directory containing some text files
and sub-directories (e.g., Level_0 and Level_1)
containing various data. It is a good idea that we fist make these
directories ready for subsequently writing to the disk. For example,
to build directories chk00016, chk00016/Level_0, and
chk00016/Level_1, we do</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">chkname</span> <span class="p">{</span><span class="s">&quot;chk00016&quot;</span><span class="p">};</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">subDirPrefix</span> <span class="p">{</span><span class="s">&quot;Level_&quot;</span><span class="p">};</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">nSubDirs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">bool</span> <span class="n">callBarrier</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Parallel barrier after directories are built.</span>
<span class="n">PreBuildDirectorHierarchy</span><span class="p">(</span><span class="n">chkname</span><span class="p">,</span> <span class="n">subDirPrefix</span><span class="p">,</span> <span class="n">nSubDirs</span><span class="p">,</span> <span class="n">callBarrier</span><span class="p">);</span>
</pre></div>
</div>
<p>A checkpoint file of AMReX&nbsp;application codes often has a clear text
Header file that only the I/O process writes to it using
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ofstream</span></span></code>. The Header file contains information such as
the time, the physical domain size, grids, etc. that are necessary for
restarting the simulation. To guarantee that precision is not lost
for storing floating point number like time in clear text file, the
file stream’s precision needs to be set properly. And a stream buffer
can also be used. For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">IOProcessor</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">chkname</span> <span class="o">=</span> <span class="s">&quot;chk00016&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">HeaderFileName</span><span class="p">(</span><span class="n">chkname</span><span class="o">+</span><span class="s">&quot;/Header&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">HeaderFile</span><span class="p">(</span><span class="n">HeaderFileName</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span>
         <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">::</span><span class="n">trunc</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
    <span class="n">HeaderFile</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;::</span><span class="n">max_digits10</span><span class="p">);</span>
    <span class="n">VisMF</span><span class="o">::</span><span class="n">IO_Buffer</span> <span class="n">io_buffer</span><span class="p">(</span><span class="n">VisMF</span><span class="o">::</span><span class="n">IO_Buffer_Size</span><span class="p">);</span>
    <span class="n">HeaderFile</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pubsetbuf</span><span class="p">(</span><span class="n">io_buffer</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">io_buffer</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Checkpoint version 1.0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="n">time</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">HeaderFile</span> <span class="o">&lt;&lt;</span> <span class="n">domain_box</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="c1">// HeaderFile &lt;&lt; ......;</span>
    <span class="n">box_array</span><span class="p">.</span><span class="n">writeOn</span><span class="p">(</span><span class="n">HeaderFile</span><span class="p">);</span> <span class="c1">// write BoxArray</span>
    <span class="c1">// HeaderFile &lt;&lt; ......;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For reading the Header file, AMReX&nbsp;can have the I/O process
read the file from the disk and broadcast it to others as
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword type"><span class="pre">char</span></span><span class="operator"><span class="pre">&gt;</span></span></code>. Then all processes can read the information with
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">istringstream</span></span></code>. For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">HeaderFileName</span> <span class="p">{</span><span class="s">&quot;chk00016/Header&quot;</span><span class="p">};</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">fileChar</span><span class="p">;</span>
<span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">ReadAndBcastFile</span><span class="p">(</span><span class="n">HeaderFileName</span><span class="p">,</span> <span class="n">fileChar</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">is</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="n">fileChar</span><span class="p">.</span><span class="n">data</span><span class="p">()},</span> <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>
<span class="c1">// is &gt;&gt; ....;</span>
<span class="n">BoxArray</span> <span class="n">ba</span><span class="p">;</span>
<span class="n">ba</span><span class="p">.</span><span class="n">readFrom</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
<span class="c1">// is &gt;&gt; ....;</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">VisMF</span></span></code> is a class that can be used to perform
MultiFab I/O in parallel. How many processes are allowed to
perform I/O simultaneously can be set via</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">VisMF</span><span class="o">::</span><span class="n">SetNOutFiles</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>  <span class="c1">// up to 64 processes, which is also the default.</span>
</pre></div>
</div>
<p>The optimal number is of course system dependent. The following code
shows how to write and read a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="p">{</span><span class="s">&quot;state&quot;</span><span class="p">};</span>

<span class="n">VisMF</span><span class="o">::</span><span class="n">Write</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>  <span class="c1">// Write MultiFab to disk</span>

<span class="c1">// Read the data to a new MultiFab</span>
<span class="c1">// WARNING: mf2 may have a completely different DistributionMapping!</span>
<span class="n">MultiFab</span> <span class="n">mf2</span><span class="p">;</span>
<span class="n">VisMF</span><span class="o">::</span><span class="n">Read</span><span class="p">(</span><span class="n">mf2</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

<span class="c1">// Read the data to a MultiFab with identical</span>
<span class="c1">// BoxArray, DistributionMapping, and number of components and ghost cells.</span>
<span class="n">MultiFab</span> <span class="nf">mf3</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">boxArray</span><span class="p">(),</span> <span class="n">mf</span><span class="p">.</span><span class="n">DistributionMap</span><span class="p">(),</span> <span class="n">mf</span><span class="p">.</span><span class="n">nComp</span><span class="p">(),</span> <span class="n">mf</span><span class="p">.</span><span class="n">nGrow</span><span class="p">());</span>
<span class="n">VisMF</span><span class="o">::</span><span class="n">Read</span><span class="p">(</span><span class="n">mf3</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>It should be emphasized that calling <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">VisMF</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Read</span></span></code> with an empty
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> (i.e., no memory allocated for floating point data)
will result in a <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> with a new <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code>
that could be different from any other existing
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">DistributionMapping</span></span></code> objects. It should also be noted that all the
data including those in ghost cells are written/read by
VisMF::Write/Read.</p>
</div>
</div>
<div class="section" id="memory-allocation">
<h1>Memory Allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">¶</a></h1>
<p>AMReX&nbsp;has a Fortran module, <code class="code fortran docutils literal"><span class="name"><span class="pre">mempool_module</span></span></code> that can be used to
allocate memory for Fortran pointers. The reason that such a module
exists in AMReX,&nbsp;is that memory allocation is often very slow in
multi-threaded OpenMP parallel regions. AMReX <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mempool_module</span></span></code>
provides a much faster alternative approach, in which each thread has
its own memory pool. Here are examples of using the module.</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">mempool_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">bl_allocate</span><span class="p">,</span> <span class="n">bl_deallocate</span>
<span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span> <span class="k">pointer</span><span class="p">,</span> <span class="k">contiguous</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(:,:,:),</span> <span class="n">b</span><span class="p">(:,:,:,:)</span>
<span class="kt">integer</span> <span class="kd">::</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">hi1</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">hi2</span><span class="p">,</span> <span class="n">lo3</span><span class="p">,</span> <span class="n">hi3</span><span class="p">,</span> <span class="n">lo</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c">! lo1 = ...</span>
<span class="c">! a(lo1:hi1, lo2:hi2, lo3:hi3)</span>
<span class="k">call </span><span class="n">bl_allocate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">hi1</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">hi2</span><span class="p">,</span> <span class="n">lo3</span><span class="p">,</span> <span class="n">hi3</span><span class="p">)</span>
<span class="c">! b(lo(1):hi(1),lo(2):hi(2),lo(3):hi(3),lo(4):hi(4))</span>
<span class="k">call </span><span class="n">bl_allocate</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
<span class="c">! ......</span>
<span class="k">call </span><span class="n">bl_deallocate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">call </span><span class="n">bl_deallocate</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The downside of this is we have to use <code class="code fortran docutils literal"><span class="keyword"><span class="pre">pointer</span></span></code> instead of
<code class="code fortran docutils literal"><span class="keyword"><span class="pre">allocatable</span></span></code>. This means we must explicitly free the memory via
<code class="code fortran docutils literal"><span class="name"><span class="pre">bl_deallocate</span></span></code> and we need to declare the pointers as
<code class="code fortran docutils literal"><span class="keyword"><span class="pre">contiguous</span></span></code> for performance reason.</p>
</div>
<div class="section" id="abort-and-assertion">
<h1>Abort and Assertion<a class="headerlink" href="#abort-and-assertion" title="Permalink to this headline">¶</a></h1>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Abort</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">const</span></span> <span class="keyword type"><span class="pre">char</span></span> <span class="operator"><span class="pre">*</span></span> <span class="name"><span class="pre">message</span></span><span class="punctuation"><span class="pre">)</span></span></code> is used to terminate a run
usually when something goes wrong. This function takes a message and
writes it to stderr. Files named like Backtrace.rg_1_rl_1
(where rg_1_rl_1 means process 1) are produced containing
backtrace information of the call stack. In Fortran, we can call
<code class="code fortran docutils literal"><span class="name"><span class="pre">amrex_abort</span></span></code> from the <code class="code fortran docutils literal"><span class="name"><span class="pre">amrex_error_module</span></span></code>, which takes a
Fortran character variable with assumed size (i.e., <code class="code fortran docutils literal"><span class="name builtin"><span class="pre">len</span></span><span class="operator"><span class="pre">=*</span></span></code>)
as a message.</p>
<p><code class="code cpp c++ docutils literal"><span class="name"><span class="pre">AMREX_ASSERT</span></span></code> is a macro that takes a Boolean expression. For
debug build (e.g., <code class="docutils literal"><span class="pre">DEBUG=TRUE</span></code> using the GNU Make build system),
if the expression at runtime is evaluated to false, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Abort</span></span></code>
will be called and the run is thus terminated. For optimized build
(e.g., <code class="docutils literal"><span class="pre">DEBUG=FALSE</span></code> using the GNU Make build system), the
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">AMREX_ASSERT</span></span></code> statement is removed at compile time and thus has no
effect at runtime. We often use this as a means of putting debug
statement in the code without adding any extra cost for production
runs. For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">AMREX_ASSERT</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">nGrow</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mf</span><span class="p">.</span><span class="n">nComp</span><span class="p">()</span> <span class="o">==</span> <span class="n">mf2</span><span class="p">.</span><span class="n">nComp</span><span class="p">());</span>
</pre></div>
</div>
<p>Here for debug build we like to assert that <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">mf</span></span></code>
has ghost cells and it also has the same number of components as
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">mf2</span></span></code>. If we always want the assertion, we can use
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">AMREX_ALWAYS_ASSERT</span></span></code>.</p>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Boundary.html" class="btn btn-neutral float-right" title="Boundary Conditions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Chapter4.html" class="btn btn-neutral" title="Basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, AMReX Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'18.02-dev',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>